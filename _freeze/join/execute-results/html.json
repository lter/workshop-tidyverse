{
  "hash": "65379d2ff03ddf33f7c1b5e4d2e538b6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Join\"\n---\n\n## Module Learning Objectives\n\nBy the end of this module, you will be able to:\n\n- <u>Differentiate</u> `dplyr`'s various `join` functions from each other\n- <u>Use</u> `dplyr`'s `left_join`, `right_join`, `inner_join`, `full_join`, and `anti_join` functions to manipulate two dataframes\n\n\n::: {.cell}\n\n:::\n\n\n## Combining data\n\nNow that we know how to manipulate a single dataframe, how do we manipulate multiple dataframes? If we have multiple sources of data and we want to combine them together into one dataframe or table, we can **join** them through any shared column(s)! Data you'll be joining can be called \"relational data\", because there is some kind of relationship between the dataframes that you’ll be leveraging. In the Tidyverse, combining data that has a relationship is called \"joining\". Let's look at some of `dplyr`'s many `join` functions!\n\nIn each of the following `join` functions, you provide two dataframes, the one you arbitrarily provide first is called the \"left\" dataframe while the other is called the \"right\" dataframe. This is important because each of the different `join` functions brings the columns from one of the dataframes into the other depending on (1) which dataframe is left and which is right and (2) what type of `join` you specify.\n\nThis becomes somewhat more intuitive when looking at tangible examples so let's prepare some data to `join` in different ways!\n\n### `join` Data Preparation\n\nFor demonstration purposes, let's add a new column called `record_number` to our penguins data and call the new dataframe `penguins_tidy`. As you can see below, each row is now numbered from 1 to the length of the dataframe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add a column called `record_number` to our penguins dataset\npenguins_tidy <- penguins %>%\n    dplyr::mutate(record_number = 1:n(), .before = dplyr::everything())\n\ndplyr::glimpse(penguins_tidy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 9\n$ record_number     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n\n\n:::\n:::\n\n\nThe `palmerpenguins` package also has a \"penguins_raw\" dataset with additional, raw information on the same penguins, such as their sampling region, unique identifier, and the date when their nest was observed. Again, for demonstration purposes, let's add a new column called `record_number` and call this new dataframe `penguins_extra`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add a column called `record_number` to our raw penguins dataset\npenguins_extra <- penguins_raw %>%\n  dplyr::mutate(record_number = 1:n()) %>%\n  # Also keep only desired columns to avoid unnecessary complexity\n  dplyr::select(record_number, Region, `Individual ID`, `Date Egg`)\n\ndplyr::glimpse(penguins_extra)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 4\n$ record_number   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ Region          <chr> \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", \"Anv…\n$ `Individual ID` <chr> \"N1A1\", \"N1A2\", \"N2A1\", \"N2A2\", \"N3A1\", \"N3A2\", \"N4A1\"…\n$ `Date Egg`      <date> 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16, 2007-…\n```\n\n\n:::\n:::\n\n\nNow that we have two dataframes that both have a column called `record_number`, we can `join` them together to combine information in various ways!\n\nAlso, note that if column names include spaces (as in `Individual ID` and `Date Egg`) they need to have a \"backtick\" (\\`) on either side. On your keyboard, a backtick (\\`) is on the left just below the \"escape\" key, and shares a button with the tilde (~).\n\n### `left_join` Example: Prioritize the \"Left\" Dataframe\n\n:::callout-note\n## Example\n\nIn a `left_join`, we bring the columns from the right dataframe that match rows found in the specified column(s) of the left dataframe.\n\n<p align=\"center\">\n<img src=\"images/join-left.png\" alt=\"Graphic showing a left join\" width=\"50%\" />\n</p>\n\nWe can specify the column that we want to join based on with `by = ...`. If we don't provide this argument, then `dplyr` will automatically join on **all** matching columns between the left and right dataframes. In our case, we want to `left_join` by `record_number`.\n\nTo better demonstrate that only rows found in the left dataframe will be joined from the right dataframe, we'll use the pipe `%>%` to `filter` the left dataframe before `join`ing. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Left-join the two dataframes together on the shared column!\npenguins_left_joined <- penguins_tidy %>%\n  dplyr::filter(record_number < 5) %>%\n  dplyr::left_join(y = penguins_extra, by = \"record_number\")\n\ndplyr::glimpse(penguins_left_joined)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 4\nColumns: 12\n$ record_number     <int> 1, 2, 3, 4\n$ species           <fct> Adelie, Adelie, Adelie, Adelie\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA\n$ flipper_length_mm <int> 181, 186, 195, NA\n$ body_mass_g       <int> 3750, 3800, 3250, NA\n$ sex               <fct> male, female, female, NA\n$ year              <int> 2007, 2007, 2007, 2007\n$ Region            <chr> \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\"\n$ `Individual ID`   <chr> \"N1A1\", \"N1A2\", \"N2A1\", \"N2A2\"\n$ `Date Egg`        <date> 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16\n```\n\n\n:::\n:::\n\n\nWhat we have in the end is `penguins_left_joined`, a dataframe with information from both `penguins_tidy` and `penguins_extra`! *All* of the rows in our `filter`ed `penguins_tidy` are kept but only the rows from `penguins_extra` that have a matching `record_number` in `penguins_tidy` are included.\n:::\n\n### `right_join` Example: Prioritize the \"Right\" Dataframe\n\n:::callout-note\n## Example\n\nIn a `right_join`, we bring rows from the left dataframe into the right dataframe based on the values in the specified column(s) of the right dataframe.\n\n<p align=\"center\">\n<img src=\"images/join-right.png\" alt=\"Graphic showing a right join\" width=\"50%\" />\n</p>\n\nAs the names imply, a `right_join` is the opposite of a `left_join`.\n:::\n\n### `inner_join` Example: Keep Rows Found in *Both* Dataframes\n\n:::callout-note\n## Example\n\nIn an `inner_join`, we keep only the rows where the values in the column we are joining `by` are found in both dataframes. \n\n<p align=\"center\">\n<img src=\"images/join-inner.png\" alt=\"Graphic showing an inner join\" width=\"50%\" />\n</p>\n\nThis can be really useful when one of the dataframes includes supplementary data that has incomplete coverage on the other dataframe and you want to simultaneously combine the dataframes and remove the inevitable `NA`s that will be created.\n\nFor example, imagine that you have a dataframe of 100 study sites with information on plant growth and a second dataframe of soil chemistry information. Your grant budget was really tight though so you needed to prioritize sample processing and you only have soil chemistry for 20 of the sites where you have plant growth data.\n\nIf you use `inner_join` on your plant growth and soil chemistry datasets, you will create a single dataframe with both chemistry and plant data that only has the sites (i.e., rows) where you had data for both. This dataframe then would likely be ready for analysis because you'd have complete data for every site in the new `join`ed dataframe!\n\nNote that in an `inner_join` it doesn't matter which dataframe is \"left\" and which is \"right\" because either way you're only keeping the rows that are found in both dataframes.\n:::\n\n### `full_join` Example: Combine *All* Data in Both Dataframes\n\n:::callout-note\n## Example\n\nIn a `full_join`, we keep all values and all rows. \n\n<p align=\"center\">\n<img src=\"images/join-full.png\" alt=\"Graphic showing a full join\" width=\"50%\" />\n</p>\n\nA `full_join` is \"smart\" enough to fill with `NA`s in all rows that don't match between the two dataframes. Also, just like an `inner_join`, a `full_join` doesn't care about which dataframe is \"left\" and which is \"right\" because all columns are getting combined regardless of which is left vs. right.\n:::\n\n### `anti_join` Example: Keep Only Columns that *Aren't* Shared\n\n:::callout-note\n## Example\n\nIn an `anti_join`, we return rows of the left dataframe that do not have a match in the right dataframe. This can be used to see what will **not** be included in a join. \n\n<p align=\"center\">\n<img src=\"images/join-anti.png\" alt=\"Graphic showing an anti join\" width=\"50%\" />\n</p>\n\nOne case where an `anti_join` is particularly useful is that of \"text mining\" where you have one dataframe with a column of individual words that you've split apart from a larger block of free text. If you also have a dataframe of one column that contains words that you want to remove from your \"actual\" data (e.g., \"and\", \"not\", \"I\", \"me\", etc.), you can `anti_join` the two dataframes to quickly remove all of those unwanted words from your text mining dataframe.\n:::\n\n### Additional Notes\n\n- If we want to join by more than one matching column, we can specify multiple columns with a vector like so: `by = c(\"column1\", \"column2\")`.\n\n- We can also use a named vector, `by = c(\"column_a\" = \"COLUMN_A\")` to match on columns that have different names in each dataframe. \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}