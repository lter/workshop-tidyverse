{
  "hash": "44e820edf376ca1294da5ab78edbc109",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Summarize\"\n---\n\n\n## Module Learning Objectives\n\nBy the end of this module, you will be able to:\n\n- <u>Describe</u> the purpose of the pipe operator (`%>%`)\n- <u>Use</u> the pipe operator (`%>%`) to chain multiple functions together\n- <u>Summarize</u> data by using `dplyr`'s `group_by` and `summarize` functions \n\n\n::: {.cell}\n\n:::\n\n\n## Pipe Operator (`%>%`)\n\nBefore diving into the Tidyverse functions that allow for summarization and group-wise operations, let's talk about the pipe operator (`%>%`). The pipe is from the `magrittr` package and allows chaining together multiple functions without needing to create separate objects at each step as you would have to without the pipe.\n\n### `%>%` Example: Using the Pipe\n\n:::callout-note\n## Example\n\nAs in the other chapters, let's use the \"penguins\" data object found in the `palmerpenguins` package. Let's say we want to keep only specimens that have a measurement for both bill length and bill depth and then remove the flipper and body mass columns.\n\nWithout the pipe--but still using other Tidyverse functions--we could go about this like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter out the NAs\npenguins_v2 <- dplyr::filter(.data = penguins,\n                              !is.na(bill_length_mm) & !is.na(bill_depth_mm))\n\n# Now strip away the columns we don't want\npenguins_v3 <- dplyr::select(.data = penguins_v2, \n                             -flipper_length_mm, -body_mass_g)\n\n# And we can look at our final product with `base::head`\ndplyr::glimpse(penguins_v3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 342\nColumns: 6\n$ species        <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie,…\n$ island         <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, …\n$ bill_length_mm <dbl> 39.1, 39.5, 40.3, 36.7, 39.3, 38.9, 39.2, 34.1, 42.0, 3…\n$ bill_depth_mm  <dbl> 18.7, 17.4, 18.0, 19.3, 20.6, 17.8, 19.6, 18.1, 20.2, 1…\n$ sex            <fct> male, female, female, female, male, female, male, NA, N…\n$ year           <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2…\n```\n\n\n:::\n:::\n\n\nUsing the pipe though we can simplify this code dramatically! Note that each of the following lines must end with the `%>%` so that R knows there are more lines to consider.\n\n::: {.cell}\n\n```{.r .cell-code}\n# We begin with the name of the data object\npenguins %>%\n  # Then we can filter the data\n  dplyr::filter(!is.na(bill_length_mm) & !is.na(bill_depth_mm)) %>%\n  # And strip away the columns we don't want\n  dplyr::select(-flipper_length_mm, -body_mass_g) %>%\n  # And we can even include the `glimpse` function to see our progress\n  dplyr::glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 342\nColumns: 6\n$ species        <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie,…\n$ island         <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, …\n$ bill_length_mm <dbl> 39.1, 39.5, 40.3, 36.7, 39.3, 38.9, 39.2, 34.1, 42.0, 3…\n$ bill_depth_mm  <dbl> 18.7, 17.4, 18.0, 19.3, 20.6, 17.8, 19.6, 18.1, 20.2, 1…\n$ sex            <fct> male, female, female, female, male, female, male, NA, N…\n$ year           <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2…\n```\n\n\n:::\n:::\n\n\nNote that using the pipe allows each line to inherit the data created by the previous line.\n:::\n\n### Challenge: `%>%`\n\n:::callout-important\n## Your Turn!\n\nUsing pipes, `filter` the data to only include male penguins, `select` only the columns for species, island, and body mass, and `filter` out any rows with NA for body mass.\n:::\n\n### Aside: Fun History of Why `%>%` is a \"Pipe\"\n\n<img src=\"images/logos/hex_magrittr.png\" alt=\"Hex logo for the 'magrittr' R package\" align=\"right\" width=\"15%\"/>\n\nThe Belgian painter René Magritte famously created a painting titled \"[The Treachery of Images](https://collections.lacma.org/node/239578)\" featuring a depiction of a smoking pipe above the words \"*Cest ci n'est pas une pipe*\" (French for \"This is not a pipe\"). Magritte's point was about how the depiction of a thing is not equal to thing itself. The `magrittr` package takes its name from the painter because it also includes a pipe that functions slightly differently from a command line pipe and uses different characters. Just like Magritte's pipe, `%>%` both is and isn't a pipe!\n\n## Group-Wise Summarizing\n\nNow that we've covered the `%>%` operator we can use it to do group-wise summarization! Technically this summarization does not *require* the pipe but it does inherently have two steps and thus benefits from using the pipe to chain together those technically separate instructions.\n\nTo summarize by groups we first define our groups using `dplyr`'s `group_by` function and then summarize using `summarize` (also from `dplyr`). `summarize` does require you to specify what calculations you want to perform within your groups though it uses similar syntax to `dplyr`'s `mutate` function.\n\n<p align=\"center\">\n<img src=\"images/summarize-group-by.png\" alt=\"Graphic of a table with an 'A' and 'B' column where the 'A' column contains one of two shapes becoming a smaller table with one row per type of shape and an 'A' and 'C' column\" width=\"50%\" />\n</p>\n\nDespite the similarity in syntax between `summarize` and `mutate` there are a few crucial differences:\n\n- `summarize` returns only a single row per group while `mutate` returns as many rows as are in the original dataframe\n- `summarize` will automatically remove any columns that aren't either (1) included in `group_by` or (2) created by `summarize`. `mutate` cannot remove columns so it only creates whatever you tell it to.\n\n### `group_by` + `summarize` Example: Summarize within Groups\n\n:::callout-note\n## Example\n\nBy using the `%>%` with `group_by` and `summarize`, we can calculate some summarized metric within our specified groups. To begin, let's find the average bill depth within each species of penguin.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Begin with the data and a pipe\npenguins %>%\n  # Group by the desired column names\n  dplyr::group_by(species) %>%\n  # And summarize in the way we desire\n  dplyr::summarize(mean_bill_dep_mm = mean(bill_depth_mm, na.rm = TRUE) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  species   mean_bill_dep_mm\n  <fct>                <dbl>\n1 Adelie                18.3\n2 Chinstrap             18.4\n3 Gentoo                15.0\n```\n\n\n:::\n:::\n\n\nNotice how the resulting dataframe only contains one row per value in the `group_by` call and only includes the grouping column and the column we created (`mean_bill_dep_mm`)? This reduction in dimensions is an inherent property of `summarize` and can be intensely valuable but be careful you don't accidentally remove columns that you want!\n:::\n\n### `group_by` + `summarize` Example: Calculate Multiple Metrics\n\n:::callout-note\n## Example\n\nLet's say we want to find *multiple* summary values for body mass of each species of penguin on each island. To accomplish this we can do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Begin with the data and a pipe\npenguins %>%\n  # Group by the desired column names\n  dplyr::group_by(species, island) %>%\n  # And summarize in the way we desire\n  dplyr::summarize(\n    # Get average body mass\n    mean_mass_g = mean(body_mass_g, na.rm = TRUE),\n    # Get the standard deviation\n    sd_mass = sd(body_mass_g, na.rm = TRUE),\n    # Count the number of individual penguins of each species at each island\n    n_mass = dplyr::n(),\n    # Calculate standard error from SD divided by count\n    se_mass = sd_mass / sqrt(n_mass) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n# Groups:   species [3]\n  species   island    mean_mass_g sd_mass n_mass se_mass\n  <fct>     <fct>           <dbl>   <dbl>  <int>   <dbl>\n1 Adelie    Biscoe          3710.    488.     44    73.5\n2 Adelie    Dream           3688.    455.     56    60.8\n3 Adelie    Torgersen       3706.    445.     52    61.7\n4 Chinstrap Dream           3733.    384.     68    46.6\n5 Gentoo    Biscoe          5076.    504.    124    45.3\n```\n\n\n:::\n:::\n\n\nYou can see that we also invoked the `n` function from `dplyr` to return the size of each group. This function reads any groups created by `group_by` and returns the count of rows in the dataframe for each group level.\n\nJust like `mutate`, `summarize` will allow you to create as many columns as you want. So, if you want metrics calculated within your groups, you only need to define each of them within the `summarize` function.\n:::\n\n### Challenge: `summarize`\n\n:::callout-important\n## Your Turn!\n\nUsing what we've covered so far, find the average flipper length in each year (regardless of any other grouping variable).\n:::\n\n## Grouping Cautionary Note\n\n`group_by` can be extremely useful in summarizing a dataframe or creating a new column without losing rows but you need to be careful. Objects created with `group_by` \"remember\" their groups until you change the groups or use the function `ungroup` from `dplyr`.\n\nLook at how the output of a grouped data object tells you the number of groups in the output (see beneath this code chunk).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  dplyr::group_by(species, island) %>%\n  dplyr::summarize(penguins_count = dplyr::n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n# Groups:   species [3]\n  species   island    penguins_count\n  <fct>     <fct>              <int>\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n```\n\n\n:::\n:::\n\n\nThis means that all future uses of that pipe will continue to use the grouping established to create the \"penguins_count\" column. We can stop this by doing the same pipe, but adding `ungroup` after we're done using the grouping established by `group_by`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  dplyr::group_by(species, island) %>%\n  dplyr::summarize(penguins_count = dplyr::n()) %>%\n  dplyr::ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  species   island    penguins_count\n  <fct>     <fct>              <int>\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n```\n\n\n:::\n:::\n\n\nSee? We calculated with our desired groups but then dropped the grouping structure once we were finished with them. Note also that if you use `group_by` and do some calculation then re-group by something else by using `group_by` *again*, the second use of `group_by` **will not be affected** by the first. This means that you only need one `ungroup` per pipe.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}