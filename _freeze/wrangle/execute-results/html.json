{
  "hash": "693ca1cb5ce537dd55be693435524c25",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Wrangle\"\n---\n\n## Module Learning Objectives\n\nBy the end of this module, you will be able to:\n\n- <u>Manipulate</u> rows and columns with `dplyr`'s `select` and `filter` functions\n- <u>Create</u> new columns with `dplyr`'s `mutate` function and fill them conditionally with `case_when` (also from `dplyr`) \n- <u>Use</u> `tidyr`'s `separate_wider_delim` function to split a column into two\n\n## What are Tidy Data?\n\nWhat are some common things you like to do with your data? Maybe remove rows or columns, do calculations and add the results as new columns? These operations (and others) are called \"data wrangling\". The data we get to work with are rarely, if ever, in the format we need to do our analyses and data wrangling can help bridge that gap. `dplyr` and `tidyr` are two R packages from the Tidyverse that provide a fairly complete and extremely powerful set of functions for us to do virtually all needed wrangling quickly. Here we introduce some commonly used functions from these two packages.\n\nWe can use `glimpse` from the `dplyr` package to look at part of the data while also getting some relevant structural information (i.e., what type of data are in each column, etc.).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"tidyverse\", \"palmerpenguins\")\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\ndplyr::glimpse(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n\n\n:::\n:::\n\n\n## Selecting Columns\n\nTo start off, how do we do a fundamental action like selecting the columns we want? `dplyr`'s `select` function provides us with a straightforward way to do just that. We only need to provide the column names!\n\n<p align=\"center\">\n<img src=\"images/wrangle-select.png\" alt=\"Graphic of a dataframe with columns labeled 'A', 'B', and 'C' being pare down to just the 'A' column\" width=\"50%\"/>\n</p>\n\nNote that even if you `select` just one column, a dataframe will be returned. Whereas if you use the `$` operator you get a vector (e.g., `data$column` returns a vector, not a dataframe).\n\n### `select` Example: Including & Excluding\n\n::: callout-note \n## Example\n\nTo select only the `species`, `island`, and `body_mass_g` columns, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Provide the name of the data and then the columns that you want!\npenguins_selected <- dplyr::select(.data = penguins, species, island, body_mass_g)\n\n# Look at the product\ndplyr::glimpse(penguins_selected)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 3\n$ species     <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Ad…\n$ island      <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, Tor…\n$ body_mass_g <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, 4250, …\n```\n\n\n:::\n:::\n\n\nIf we want to remove specific columns, we can use the `-` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Put a \"-\" in front of each column you would like to remove from your dataframe\npenguins_selected <- dplyr::select(.data = penguins, -flipper_length_mm, -sex)\n\n# Look at the product\ndplyr::glimpse(penguins_selected)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 6\n$ species        <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie,…\n$ island         <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, …\n$ bill_length_mm <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, 42.…\n$ bill_depth_mm  <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, 20.…\n$ body_mass_g    <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, 425…\n$ year           <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2…\n```\n\n\n:::\n:::\n\n:::\n\n### `select` Example: Selecting with Helper Functions\n\n::: callout-note\n## Example\n\nIf we want to select the columns that contain length measurements, we can manually type `bill_length_mm` and `flipper_length_mm`, but there's actually an easier way using the `contains` function, also from the `dplyr` package. Enter a string that matches what you're looking for among the column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enter a matching string inside of a `select` call\npenguins_selected <- dplyr::select(.data = penguins, dplyr::contains(\"length\"))\n\n# Look at the product\ndplyr::glimpse(penguins_selected)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 2\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n```\n\n\n:::\n:::\n\n:::\n\n### `select` Example: Selecting a Range of Columns\n\n:::callout-note\n## Example\n\nNow what if we wanted all the columns from the first column `species` to the sixth column `body_mass_g`? We can use a colon, `:`, between the first (leftmost) and last (rightmost) columns in the range that we want to include.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use a colon to indicate a range of columns you want to select\npenguins_selected <- dplyr::select(.data = penguins, species:body_mass_g)\n\n# Look at the product\ndplyr::glimpse(penguins_selected)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 6\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n```\n\n\n:::\n:::\n\n\nConveniently selecting a range of columns can be especially useful when you have a big dataframe and don't want to exhaustively list every column by name.\n:::\n\n## Subsetting Rows\n\nInstead of selecting certain columns, how can we get a subset of rows that meet certain conditions? For example, in the diagram below, how can we filter for rows that contain a diamond shape? We can use `dplyr`'s handy `filter` function along with logical and boolean operators!\n\n<p align=\"center\">\n<img src=\"images/wrangle-filter.png\" alt=\"Graphic of a table with only an 'A' column and rows with different shapes getting subsetted to only the row with a diamond\" width=\"25%\"/>\n</p>\n\nFor reference, here are the operators we can use to specify our conditions with `filter`.\n\n- `==` -- two items are exactly equal to one another\n- `!=` -- two items are not equal to one another \n- `<`/`>` -- one item is less/greater than the other \n- `<=`/`>=` -- one item is less/greater than or equal to the other \n- `|` -- one statement _or_ another is `TRUE`\n- `&` -- _both_ statements are `TRUE`\n- `%in%` -- a value is in a set of other values\n\nYou may have noticed that `filter` accepts the same operators that base R's `subset` function does. This is no accident and `filter` is one of the more accessible Tidyverse functions because the syntax it shares with its base R equivalent.\n\nTo get familiar with these operators, let's see some examples!\n\n### `filter` Example: Exactly Equal\n\n:::callout-note\n## Example\n\nTo make a subset of our data that only contains information on Chinstrap penguins, we would use the `==` operator for \"exactly equal to\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is \"Chinstrap\" \npenguins_filtered <- dplyr::filter(.data = penguins, species == \"Chinstrap\")\n\nhead(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n1 Chinstrap Dream            46.5          17.9               192        3500\n2 Chinstrap Dream            50            19.5               196        3900\n3 Chinstrap Dream            51.3          19.2               193        3650\n4 Chinstrap Dream            45.4          18.7               188        3525\n5 Chinstrap Dream            52.7          19.8               197        3725\n6 Chinstrap Dream            45.2          17.8               198        3950\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\nNote that we need to write the value we're looking for as a character string bookended by quotation marks.\n:::\n\n### `filter` Example: Either / Or\n\n:::callout-note\n## Example\n\nWhat if we wanted to get all the rows where the penguin species is \"Chinstrap\" **or** \"Gentoo\"? In other words, we want all the rows where *either* condition is true. There are two options to do this. The first option is to use the \"or\" operator (`|`) between each of the conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Chinstrap\" | species == \"Gentoo\")\n\nunique(penguins_filtered$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Gentoo    Chinstrap\nLevels: Adelie Chinstrap Gentoo\n```\n\n\n:::\n:::\n\n\nThis method works fine for a few options but begins to get cumbersome when you have many possible conditions that you'd like to retain. In these cases you can use the `%in%` operator followed by a vector of values that you want to include in your filter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species %in% c(\"Chinstrap\", \"Gentoo\"))\n\nunique(penguins_filtered$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Gentoo    Chinstrap\nLevels: Adelie Chinstrap Gentoo\n```\n\n\n:::\n:::\n\n:::\n\n### `filter` Example: Multiple Conditions\n\n:::callout-note\n## Example\n\nWe can also keep rows where both conditions are met by using the `&` operator to specify multiple conditions that must *all* be true. To keep only the rows where the species is \"Adelie\" **and** the island is \"Dream\", we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is \"Adelie\" and the island is \"Dream\"\npenguins_filtered <- dplyr::filter(.data = penguins,\n                             species == \"Adelie\" & island == \"Dream\")\n\ndplyr::glimpse(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 56\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Dream, Dream, Dream, Dream, Dream, Dream, Dream, Dre…\n$ bill_length_mm    <dbl> 39.5, 37.2, 39.5, 40.9, 36.4, 39.2, 38.8, 42.2, 37.6…\n$ bill_depth_mm     <dbl> 16.7, 18.1, 17.8, 18.9, 17.0, 21.1, 20.0, 18.5, 19.3…\n$ flipper_length_mm <int> 178, 178, 188, 184, 195, 196, 190, 180, 181, 184, 18…\n$ body_mass_g       <int> 3250, 3900, 3300, 3900, 3325, 4150, 3950, 3550, 3300…\n$ sex               <fct> female, male, female, male, female, male, male, fema…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n\n\n:::\n:::\n\n:::\n\n### `filter` Example: Greater Than / Less Than\n\n:::callout-note\n## Example\n\nWhen subsetting by numeric columns, we can use greater than (`>`) and less than (`<`) to capture the range of possible values that meet that criteria. If you want to include an \"or equal to\" clause, just add an equal sign to the right of the greater/less than sign (e.g., `>=` or `<=`). \n\nFor instance, we can subset the data for only penguins whose bills are longer than 50 millimeters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter based on bill length\npenguins_filtered <- dplyr::filter(.data = penguins, bill_length_mm > 50)\n\nsort(penguins_filtered$bill_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 50.1 50.1 50.2 50.2 50.2 50.3 50.4 50.4 50.5 50.5 50.5 50.5 50.5 50.6 50.7\n[16] 50.7 50.8 50.8 50.8 50.8 50.9 50.9 51.0 51.1 51.1 51.3 51.3 51.3 51.3 51.4\n[31] 51.5 51.5 51.7 51.9 52.0 52.0 52.0 52.1 52.2 52.2 52.5 52.7 52.8 53.4 53.5\n[46] 54.2 54.3 55.1 55.8 55.9 58.0 59.6\n```\n\n\n:::\n:::\n\n\nNote that when filtering for numeric columns we do not need the quotation marks around the number(s) we use to filter.\n:::\n\n### `filter` Example: Exclusion Criteria\n\n:::callout-note\n## Example\n\nSometimes it's faster to subset the rows that **do not** meet a condition, rather than listing everything that we do want to keep. This is where the `!=` operator (or \"not equal to\") becomes useful. More generally, the exclamation mark indicates negation in the operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all the rows where the species is NOT \"Chinstrap\"\npenguins_filtered <- dplyr::filter(.data = penguins, species != \"Chinstrap\")\n\ndplyr::glimpse(penguins_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 276\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n\n\n:::\n:::\n\n:::\n\n### Challenge: `filter`\n\n:::callout-important\n## Your Turn!\n\nUsing `filter`, how would you get all of the rows that **do not** have any `NA` values in the `sex` column?\n:::\n\n## Making and Modifying Columns\n\nAside from selecting columns and subsetting rows, we may want to create new columns in our data. For instance, in the diagram below, we have a dataframe that only contains column A, and then we add new columns B and C. We can use `dplyr`'s `mutate` function to add a new column, while keeping the existing columns.\n\n<p align=\"center\">\n<img src=\"images/wrangle-mutate.png\" alt=\"Graphic of a table with an 'A' column gaining a 'B' and 'C' column\" width=\"50%\"/>\n</p>\n\nThe general syntax to add a new column to your dataframe is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyour_data_v2 <- dplyr::mutate(.data = your_data, new_column_name = what_it_contains)\n```\n:::\n\n\n### `mutate` Example: Making New Columns\n\n:::callout-note\n## Example\n\nIf we wanted to add a new column that has the penguin's body mass in kilograms, we can do some arithmetic on the `body_mass_g` column and store the result in a new column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a new column with the penguins' body mass in kilograms\npenguins_mutated <- dplyr::mutate(.data = penguins, body_mass_kg = body_mass_g / 1000)\n\ndplyr::glimpse(penguins_mutated)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 9\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ body_mass_kg      <dbl> 3.750, 3.800, 3.250, NA, 3.450, 3.650, 3.625, 4.675,…\n```\n\n\n:::\n:::\n\n:::\n\n### `mutate` Example: Overwriting Existing Columns\n\n:::callout-note\n## Example\n\nAdditionally, `mutate` can be used to overwrite an existing column. If we give the new column the same name as an existing column, the existing column will be **replaced**. As you can see, `island` is currently a factor. To change its class to a character, we would need to overwrite the column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check current format of the `island` column\nclass(penguins$island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Modify the existing island column\npenguins_mutated <- dplyr::mutate(.data = penguins, island = as.character(island))\n\n# the `island` column is now a character!\nclass(penguins_mutated$island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\nNow `island` is a character column!\n:::\n\n### Conditional Operations\n\nSometimes in data wrangling we'll want to generate a new column where the contents of the column are dependent upon an existing column but we have many separate \"if X then Y\" type statements. Such statements are called \"conditional\" statements in programming. You may already be familiar with base R's `ifelse` function for handling cases where you have an either/or condition.\n\nIn the Tidyverse--specifically `dplyr`--we have `case_when` for handling multiple conditions in an efficient and relatively straightforward way! Why are we talking about `case_when` here? Because you can use `case_when` inside of a `mutate` to create a new column based on the conditions that you specify.\n\nHere is what the general syntax for this operation looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyour_data_v2 <- dplyr::mutate(.data = your_data,\n                              new_column_name = dplyr::case_when(\n                                  condition1 ~ value_for_condition1,\n                                  condition2 ~ value_for_condition2,\n                                  condition3 ~ value_for_condition3,\n                                  ...\n                                  TRUE ~ value_if_no_conditions_are_met))\n```\n:::\n\n\nLet's look at an example to make this somewhat more tangible.\n\n### `mutate` + `case_when` Example: Creating a New Column Conditionally\n\n:::callout-note\n## Example\n\nSuppose we want to add a new column called `flipper_rank` that contains the following:\n\n-   \"short\" if `flipper_length_mm` is \\< 190 mm\n-   \"long\" if `flipper_length_mm` is \\>= 190 mm\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enter your conditions on the left side and the values on the right side of the tilde\npenguins_mutated <- dplyr::mutate(.data = penguins,\n                                  flipper_rank = dplyr::case_when(\n                                    flipper_length_mm < 190 ~ \"short\",\n                                    flipper_length_mm >= 190 ~ \"long\")\n)\n\ndplyr::glimpse(penguins_mutated)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 9\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ flipper_rank      <chr> \"short\", \"short\", \"long\", NA, \"long\", \"long\", \"short…\n```\n\n\n:::\n:::\n\n:::\n\n### Challenge: `mutate` + `case_when`\n\n:::callout-important\n## Your Turn!\n\nUsing `mutate` and `case_when`, create a new column called `size_bin` that contains the following:\n\n-   \"large\" if body mass is greater than 4500 grams\n-   \"medium\" if body mass is greater than 3000 grams, and less than or equal to 4500 grams\n-   \"small\" if body mass is less than or equal to 3000 grams\n:::\n\n### Splitting a Column into Multiple Columns\n\nAnother relatively common task in data wrangling involves splitting the contents of one column into several columns. To demonstrate, let's first make a new column that contains the full scientific names for these penguins using `mutate` and `case_when`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remember that conditions are on the left side and the values are on the right side of the tilde\npenguins_v1 <- dplyr::mutate(.data = penguins, \n                             scientific_name = dplyr::case_when(\n                               species == \"Adelie\" ~ \"Pygoscelis_adeliae\",\n                               species == \"Chinstrap\" ~ \"Pygoscelis_antarcticus\",\n                               species == \"Gentoo\" ~ \"Pygoscelis_papua\"))\n\ndplyr::glimpse(penguins_v1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 9\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ scientific_name   <chr> \"Pygoscelis_adeliae\", \"Pygoscelis_adeliae\", \"Pygosce…\n```\n\n\n:::\n:::\n\n\nIf we want to split the scientific name into genus and specific epithet, we can use the `separate_wider_delim` function from the `tidyr` package.\n\n### `separate_wider_delim` Example: Splitting a Column Apart\n\n:::callout-note\n## Example\n\nUsing our new scientific name column, suppose we want to split it so that `scientific_name` becomes two columns: `genus` and `epithet`. Using `tidyr`'s `separate_wider_delim` function we can do this in a single step!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Indicate the column you want to split, the separator, and the new column names!\npenguins_separated <- tidyr::separate_wider_delim(data = penguins_v1,\n                                                  cols = scientific_name,\n                                                  delim = \"_\",\n                                                  names = c(\"genus\", \"epithet\"))\n\ndplyr::glimpse(penguins_separated)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 10\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ genus             <chr> \"Pygoscelis\", \"Pygoscelis\", \"Pygoscelis\", \"Pygosceli…\n$ epithet           <chr> \"adeliae\", \"adeliae\", \"adeliae\", \"adeliae\", \"adeliae…\n```\n\n\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}