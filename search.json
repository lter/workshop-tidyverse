[
  {
    "objectID": "wrangle.html",
    "href": "wrangle.html",
    "title": "Wrangle",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nManipulate rows and columns with dplyr’s select and filter functions\nCreate new columns with dplyr’s mutate function and fill them conditionally with case_when (also from dplyr)\nUse tidyr’s separate_wider_delim function to split a column into two",
    "crumbs": [
      "Modules",
      "Wrangle"
    ]
  },
  {
    "objectID": "wrangle.html#module-learning-objectives",
    "href": "wrangle.html#module-learning-objectives",
    "title": "Wrangle",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nManipulate rows and columns with dplyr’s select and filter functions\nCreate new columns with dplyr’s mutate function and fill them conditionally with case_when (also from dplyr)\nUse tidyr’s separate_wider_delim function to split a column into two",
    "crumbs": [
      "Modules",
      "Wrangle"
    ]
  },
  {
    "objectID": "wrangle.html#what-are-tidy-data",
    "href": "wrangle.html#what-are-tidy-data",
    "title": "Wrangle",
    "section": "What are Tidy Data?",
    "text": "What are Tidy Data?\nWhat are some common things you like to do with your data? Maybe remove rows or columns, do calculations and add the results as new columns? These operations (and others) are called “data wrangling”. The data we get to work with are rarely, if ever, in the format we need to do our analyses and data wrangling can help bridge that gap. dplyr and tidyr are two R packages from the Tidyverse that provide a fairly complete and extremely powerful set of functions for us to do virtually all needed wrangling quickly. Here we introduce some commonly used functions from these two packages.\nWe can use glimpse from the dplyr package to look at part of the data while also getting some relevant structural information (i.e., what type of data are in each column, etc.).\n\n# install.packages(\"tidyverse\", \"palmerpenguins\")\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\ndplyr::glimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…",
    "crumbs": [
      "Modules",
      "Wrangle"
    ]
  },
  {
    "objectID": "wrangle.html#selecting-columns",
    "href": "wrangle.html#selecting-columns",
    "title": "Wrangle",
    "section": "Selecting Columns",
    "text": "Selecting Columns\nTo start off, how do we do a fundamental action like selecting the columns we want? dplyr’s select function provides us with a straightforward way to do just that. We only need to provide the column names!\n\n\n\nNote that even if you select just one column, a dataframe will be returned. Whereas if you use the $ operator you get a vector (e.g., data$column returns a vector, not a dataframe).\n\nselect Example: Including & Excluding\n\n\n\n\n\n\nExample\n\n\n\nTo select only the species, island, and body_mass_g columns, we can use the following code:\n\n# Provide the name of the data and then the columns that you want!\npenguins_selected &lt;- dplyr::select(.data = penguins, species, island, body_mass_g)\n\n# Look at the product\ndplyr::glimpse(penguins_selected)\n\nRows: 344\nColumns: 3\n$ species     &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Ad…\n$ island      &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, Tor…\n$ body_mass_g &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, 4250, …\n\n\nIf we want to remove specific columns, we can use the - operator.\n\n# Put a \"-\" in front of each column you would like to remove from your dataframe\npenguins_selected &lt;- dplyr::select(.data = penguins, -flipper_length_mm, -sex)\n\n# Look at the product\ndplyr::glimpse(penguins_selected)\n\nRows: 344\nColumns: 6\n$ species        &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie,…\n$ island         &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, …\n$ bill_length_mm &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, 42.…\n$ bill_depth_mm  &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, 20.…\n$ body_mass_g    &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, 425…\n$ year           &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2…\n\n\n\n\n\n\nselect Example: Selecting with Helper Functions\n\n\n\n\n\n\nExample\n\n\n\nIf we want to select the columns that contain length measurements, we can manually type bill_length_mm and flipper_length_mm, but there’s actually an easier way using the contains function, also from the dplyr package. Enter a string that matches what you’re looking for among the column names.\n\n# Enter a matching string inside of a `select` call\npenguins_selected &lt;- dplyr::select(.data = penguins, dplyr::contains(\"length\"))\n\n# Look at the product\ndplyr::glimpse(penguins_selected)\n\nRows: 344\nColumns: 2\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n\n\n\n\n\n\nselect Example: Selecting a Range of Columns\n\n\n\n\n\n\nExample\n\n\n\nNow what if we wanted all the columns from the first column species to the sixth column body_mass_g? We can use a colon, :, between the first (leftmost) and last (rightmost) columns in the range that we want to include.\n\n# Use a colon to indicate a range of columns you want to select\npenguins_selected &lt;- dplyr::select(.data = penguins, species:body_mass_g)\n\n# Look at the product\ndplyr::glimpse(penguins_selected)\n\nRows: 344\nColumns: 6\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n\n\nConveniently selecting a range of columns can be especially useful when you have a big dataframe and don’t want to exhaustively list every column by name.",
    "crumbs": [
      "Modules",
      "Wrangle"
    ]
  },
  {
    "objectID": "wrangle.html#subsetting-rows",
    "href": "wrangle.html#subsetting-rows",
    "title": "Wrangle",
    "section": "Subsetting Rows",
    "text": "Subsetting Rows\nInstead of selecting certain columns, how can we get a subset of rows that meet certain conditions? For example, in the diagram below, how can we filter for rows that contain a diamond shape? We can use dplyr’s handy filter function along with logical and boolean operators!\n\n\n\nFor reference, here are the operators we can use to specify our conditions with filter.\n\n== – two items are exactly equal to one another\n!= – two items are not equal to one another\n&lt;/&gt; – one item is less/greater than the other\n&lt;=/&gt;= – one item is less/greater than or equal to the other\n| – one statement or another is TRUE\n& – both statements are TRUE\n%in% – a value is in a set of other values\n\nYou may have noticed that filter accepts the same operators that base R’s subset function does. This is no accident and filter is one of the more accessible Tidyverse functions because the syntax it shares with its base R equivalent.\nTo get familiar with these operators, let’s see some examples!\n\nfilter Example: Exactly Equal\n\n\n\n\n\n\nExample\n\n\n\nTo make a subset of our data that only contains information on Chinstrap penguins, we would use the == operator for “exactly equal to”\n\n# Get all the rows where the species is \"Chinstrap\" \npenguins_filtered &lt;- dplyr::filter(.data = penguins, species == \"Chinstrap\")\n\nhead(penguins_filtered)\n\n# A tibble: 6 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Chinstrap Dream            46.5          17.9               192        3500\n2 Chinstrap Dream            50            19.5               196        3900\n3 Chinstrap Dream            51.3          19.2               193        3650\n4 Chinstrap Dream            45.4          18.7               188        3525\n5 Chinstrap Dream            52.7          19.8               197        3725\n6 Chinstrap Dream            45.2          17.8               198        3950\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nNote that we need to write the value we’re looking for as a character string bookended by quotation marks.\n\n\n\n\nfilter Example: Either / Or\n\n\n\n\n\n\nExample\n\n\n\nWhat if we wanted to get all the rows where the penguin species is “Chinstrap” or “Gentoo”? In other words, we want all the rows where either condition is true. There are two options to do this. The first option is to use the “or” operator (|) between each of the conditions.\n\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered &lt;- dplyr::filter(.data = penguins,\n                             species == \"Chinstrap\" | species == \"Gentoo\")\n\nunique(penguins_filtered$species)\n\n[1] Gentoo    Chinstrap\nLevels: Adelie Chinstrap Gentoo\n\n\nThis method works fine for a few options but begins to get cumbersome when you have many possible conditions that you’d like to retain. In these cases you can use the %in% operator followed by a vector of values that you want to include in your filter.\n\n# Get all the rows where the species is \"Chinstrap\" or \"Gentoo\"\npenguins_filtered &lt;- dplyr::filter(.data = penguins,\n                             species %in% c(\"Chinstrap\", \"Gentoo\"))\n\nunique(penguins_filtered$species)\n\n[1] Gentoo    Chinstrap\nLevels: Adelie Chinstrap Gentoo\n\n\n\n\n\n\nfilter Example: Multiple Conditions\n\n\n\n\n\n\nExample\n\n\n\nWe can also keep rows where both conditions are met by using the & operator to specify multiple conditions that must all be true. To keep only the rows where the species is “Adelie” and the island is “Dream”, we can use the following code:\n\n# Get all the rows where the species is \"Adelie\" and the island is \"Dream\"\npenguins_filtered &lt;- dplyr::filter(.data = penguins,\n                             species == \"Adelie\" & island == \"Dream\")\n\ndplyr::glimpse(penguins_filtered)\n\nRows: 56\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Dream, Dream, Dream, Dream, Dream, Dream, Dream, Dre…\n$ bill_length_mm    &lt;dbl&gt; 39.5, 37.2, 39.5, 40.9, 36.4, 39.2, 38.8, 42.2, 37.6…\n$ bill_depth_mm     &lt;dbl&gt; 16.7, 18.1, 17.8, 18.9, 17.0, 21.1, 20.0, 18.5, 19.3…\n$ flipper_length_mm &lt;int&gt; 178, 178, 188, 184, 195, 196, 190, 180, 181, 184, 18…\n$ body_mass_g       &lt;int&gt; 3250, 3900, 3300, 3900, 3325, 4150, 3950, 3550, 3300…\n$ sex               &lt;fct&gt; female, male, female, male, female, male, male, fema…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\nfilter Example: Greater Than / Less Than\n\n\n\n\n\n\nExample\n\n\n\nWhen subsetting by numeric columns, we can use greater than (&gt;) and less than (&lt;) to capture the range of possible values that meet that criteria. If you want to include an “or equal to” clause, just add an equal sign to the right of the greater/less than sign (e.g., &gt;= or &lt;=).\nFor instance, we can subset the data for only penguins whose bills are longer than 50 millimeters.\n\n# Filter based on bill length\npenguins_filtered &lt;- dplyr::filter(.data = penguins, bill_length_mm &gt; 50)\n\nsort(penguins_filtered$bill_length_mm)\n\n [1] 50.1 50.1 50.2 50.2 50.2 50.3 50.4 50.4 50.5 50.5 50.5 50.5 50.5 50.6 50.7\n[16] 50.7 50.8 50.8 50.8 50.8 50.9 50.9 51.0 51.1 51.1 51.3 51.3 51.3 51.3 51.4\n[31] 51.5 51.5 51.7 51.9 52.0 52.0 52.0 52.1 52.2 52.2 52.5 52.7 52.8 53.4 53.5\n[46] 54.2 54.3 55.1 55.8 55.9 58.0 59.6\n\n\nNote that when filtering for numeric columns we do not need the quotation marks around the number(s) we use to filter.\n\n\n\n\nfilter Example: Exclusion Criteria\n\n\n\n\n\n\nExample\n\n\n\nSometimes it’s faster to subset the rows that do not meet a condition, rather than listing everything that we do want to keep. This is where the != operator (or “not equal to”) becomes useful. More generally, the exclamation mark indicates negation in the operator.\n\n# Get all the rows where the species is NOT \"Chinstrap\"\npenguins_filtered &lt;- dplyr::filter(.data = penguins, species != \"Chinstrap\")\n\ndplyr::glimpse(penguins_filtered)\n\nRows: 276\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\nChallenge: filter\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing filter, how would you get all of the rows that do not have any NA values in the sex column?",
    "crumbs": [
      "Modules",
      "Wrangle"
    ]
  },
  {
    "objectID": "wrangle.html#making-and-modifying-columns",
    "href": "wrangle.html#making-and-modifying-columns",
    "title": "Wrangle",
    "section": "Making and Modifying Columns",
    "text": "Making and Modifying Columns\nAside from selecting columns and subsetting rows, we may want to create new columns in our data. For instance, in the diagram below, we have a dataframe that only contains column A, and then we add new columns B and C. We can use dplyr’s mutate function to add a new column, while keeping the existing columns.\n\n\n\nThe general syntax to add a new column to your dataframe is as follows:\n\nyour_data_v2 &lt;- dplyr::mutate(.data = your_data, new_column_name = what_it_contains)\n\n\nmutate Example: Making New Columns\n\n\n\n\n\n\nExample\n\n\n\nIf we wanted to add a new column that has the penguin’s body mass in kilograms, we can do some arithmetic on the body_mass_g column and store the result in a new column.\n\n# Create a new column with the penguins' body mass in kilograms\npenguins_mutated &lt;- dplyr::mutate(.data = penguins, body_mass_kg = body_mass_g / 1000)\n\ndplyr::glimpse(penguins_mutated)\n\nRows: 344\nColumns: 9\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ body_mass_kg      &lt;dbl&gt; 3.750, 3.800, 3.250, NA, 3.450, 3.650, 3.625, 4.675,…\n\n\n\n\n\n\nmutate Example: Overwriting Existing Columns\n\n\n\n\n\n\nExample\n\n\n\nAdditionally, mutate can be used to overwrite an existing column. If we give the new column the same name as an existing column, the existing column will be replaced. As you can see, island is currently a factor. To change its class to a character, we would need to overwrite the column.\n\n# Check current format of the `island` column\nclass(penguins$island)\n\n[1] \"factor\"\n\n# Modify the existing island column\npenguins_mutated &lt;- dplyr::mutate(.data = penguins, island = as.character(island))\n\n# the `island` column is now a character!\nclass(penguins_mutated$island)\n\n[1] \"character\"\n\n\nNow island is a character column!\n\n\n\n\nConditional Operations\nSometimes in data wrangling we’ll want to generate a new column where the contents of the column are dependent upon an existing column but we have many separate “if X then Y” type statements. Such statements are called “conditional” statements in programming. You may already be familiar with base R’s ifelse function for handling cases where you have an either/or condition.\nIn the Tidyverse–specifically dplyr–we have case_when for handling multiple conditions in an efficient and relatively straightforward way! Why are we talking about case_when here? Because you can use case_when inside of a mutate to create a new column based on the conditions that you specify.\nHere is what the general syntax for this operation looks like:\n\nyour_data_v2 &lt;- dplyr::mutate(.data = your_data,\n                              new_column_name = dplyr::case_when(\n                                  condition1 ~ value_for_condition1,\n                                  condition2 ~ value_for_condition2,\n                                  condition3 ~ value_for_condition3,\n                                  ...\n                                  TRUE ~ value_if_no_conditions_are_met))\n\nLet’s look at an example to make this somewhat more tangible.\n\n\nmutate + case_when Example: Creating a New Column Conditionally\n\n\n\n\n\n\nExample\n\n\n\nSuppose we want to add a new column called flipper_rank that contains the following:\n\n“short” if flipper_length_mm is &lt; 190 mm\n“long” if flipper_length_mm is &gt;= 190 mm\n\n\n# Enter your conditions on the left side and the values on the right side of the tilde\npenguins_mutated &lt;- dplyr::mutate(.data = penguins,\n                                  flipper_rank = dplyr::case_when(\n                                    flipper_length_mm &lt; 190 ~ \"short\",\n                                    flipper_length_mm &gt;= 190 ~ \"long\")\n)\n\ndplyr::glimpse(penguins_mutated)\n\nRows: 344\nColumns: 9\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ flipper_rank      &lt;chr&gt; \"short\", \"short\", \"long\", NA, \"long\", \"long\", \"short…\n\n\n\n\n\n\nChallenge: mutate + case_when\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing mutate and case_when, create a new column called size_bin that contains the following:\n\n“large” if body mass is greater than 4500 grams\n“medium” if body mass is greater than 3000 grams, and less than or equal to 4500 grams\n“small” if body mass is less than or equal to 3000 grams\n\n\n\n\n\nSplitting a Column into Multiple Columns\nAnother relatively common task in data wrangling involves splitting the contents of one column into several columns. To demonstrate, let’s first make a new column that contains the full scientific names for these penguins using mutate and case_when.\n\n# Remember that conditions are on the left side and the values are on the right side of the tilde\npenguins_v1 &lt;- dplyr::mutate(.data = penguins, \n                             scientific_name = dplyr::case_when(\n                               species == \"Adelie\" ~ \"Pygoscelis_adeliae\",\n                               species == \"Chinstrap\" ~ \"Pygoscelis_antarcticus\",\n                               species == \"Gentoo\" ~ \"Pygoscelis_papua\"))\n\ndplyr::glimpse(penguins_v1)\n\nRows: 344\nColumns: 9\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ scientific_name   &lt;chr&gt; \"Pygoscelis_adeliae\", \"Pygoscelis_adeliae\", \"Pygosce…\n\n\nIf we want to split the scientific name into genus and specific epithet, we can use the separate_wider_delim function from the tidyr package.\n\n\nseparate_wider_delim Example: Splitting a Column Apart\n\n\n\n\n\n\nExample\n\n\n\nUsing our new scientific name column, suppose we want to split it so that scientific_name becomes two columns: genus and epithet. Using tidyr’s separate_wider_delim function we can do this in a single step!\n\n# Indicate the column you want to split, the separator, and the new column names!\npenguins_separated &lt;- tidyr::separate_wider_delim(data = penguins_v1,\n                                                  cols = scientific_name,\n                                                  delim = \"_\",\n                                                  names = c(\"genus\", \"epithet\"))\n\ndplyr::glimpse(penguins_separated)\n\nRows: 344\nColumns: 10\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ genus             &lt;chr&gt; \"Pygoscelis\", \"Pygoscelis\", \"Pygoscelis\", \"Pygosceli…\n$ epithet           &lt;chr&gt; \"adeliae\", \"adeliae\", \"adeliae\", \"adeliae\", \"adeliae…",
    "crumbs": [
      "Modules",
      "Wrangle"
    ]
  },
  {
    "objectID": "summarize.html",
    "href": "summarize.html",
    "title": "Summarize",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDescribe the purpose of the pipe operator (%&gt;%)\nUse the pipe operator (%&gt;%) to chain multiple functions together\nSummarize data by using dplyr’s group_by and summarize functions",
    "crumbs": [
      "Modules",
      "Summarize"
    ]
  },
  {
    "objectID": "summarize.html#module-learning-objectives",
    "href": "summarize.html#module-learning-objectives",
    "title": "Summarize",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDescribe the purpose of the pipe operator (%&gt;%)\nUse the pipe operator (%&gt;%) to chain multiple functions together\nSummarize data by using dplyr’s group_by and summarize functions",
    "crumbs": [
      "Modules",
      "Summarize"
    ]
  },
  {
    "objectID": "summarize.html#pipe-operator",
    "href": "summarize.html#pipe-operator",
    "title": "Summarize",
    "section": "Pipe Operator (%>%)",
    "text": "Pipe Operator (%&gt;%)\nBefore diving into the Tidyverse functions that allow for summarization and group-wise operations, let’s talk about the pipe operator (%&gt;%). The pipe is from the magrittr package and allows chaining together multiple functions without needing to create separate objects at each step as you would have to without the pipe.\n\n%&gt;% Example: Using the Pipe\n\n\n\n\n\n\nExample\n\n\n\nAs in the other chapters, let’s use the “penguins” data object found in the palmerpenguins package. Let’s say we want to keep only specimens that have a measurement for both bill length and bill depth and then remove the flipper and body mass columns.\nWithout the pipe–but still using other Tidyverse functions–we could go about this like this:\n\n# Filter out the NAs\npenguins_v2 &lt;- dplyr::filter(.data = penguins,\n                              !is.na(bill_length_mm) & !is.na(bill_depth_mm))\n\n# Now strip away the columns we don't want\npenguins_v3 &lt;- dplyr::select(.data = penguins_v2, \n                             -flipper_length_mm, -body_mass_g)\n\n# And we can look at our final product with `base::head`\ndplyr::glimpse(penguins_v3)\n\nRows: 342\nColumns: 6\n$ species        &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie,…\n$ island         &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, …\n$ bill_length_mm &lt;dbl&gt; 39.1, 39.5, 40.3, 36.7, 39.3, 38.9, 39.2, 34.1, 42.0, 3…\n$ bill_depth_mm  &lt;dbl&gt; 18.7, 17.4, 18.0, 19.3, 20.6, 17.8, 19.6, 18.1, 20.2, 1…\n$ sex            &lt;fct&gt; male, female, female, female, male, female, male, NA, N…\n$ year           &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2…\n\n\nUsing the pipe though we can simplify this code dramatically! Note that each of the following lines must end with the %&gt;% so that R knows there are more lines to consider.\n\n# We begin with the name of the data object\npenguins %&gt;%\n  # Then we can filter the data\n  dplyr::filter(!is.na(bill_length_mm) & !is.na(bill_depth_mm)) %&gt;%\n  # And strip away the columns we don't want\n  dplyr::select(-flipper_length_mm, -body_mass_g) %&gt;%\n  # And we can even include the `glimpse` function to see our progress\n  dplyr::glimpse()\n\nRows: 342\nColumns: 6\n$ species        &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie,…\n$ island         &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, …\n$ bill_length_mm &lt;dbl&gt; 39.1, 39.5, 40.3, 36.7, 39.3, 38.9, 39.2, 34.1, 42.0, 3…\n$ bill_depth_mm  &lt;dbl&gt; 18.7, 17.4, 18.0, 19.3, 20.6, 17.8, 19.6, 18.1, 20.2, 1…\n$ sex            &lt;fct&gt; male, female, female, female, male, female, male, NA, N…\n$ year           &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2…\n\n\nNote that using the pipe allows each line to inherit the data created by the previous line.\n\n\n\n\nChallenge: %&gt;%\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing pipes, filter the data to only include male penguins, select only the columns for species, island, and body mass, and filter out any rows with NA for body mass.\n\n\n\n\nAside: Fun History of Why %&gt;% is a “Pipe”\n\nThe Belgian painter René Magritte famously created a painting titled “The Treachery of Images” featuring a depiction of a smoking pipe above the words “Cest ci n’est pas une pipe” (French for “This is not a pipe”). Magritte’s point was about how the depiction of a thing is not equal to thing itself. The magrittr package takes its name from the painter because it also includes a pipe that functions slightly differently from a command line pipe and uses different characters. Just like Magritte’s pipe, %&gt;% both is and isn’t a pipe!",
    "crumbs": [
      "Modules",
      "Summarize"
    ]
  },
  {
    "objectID": "summarize.html#group-wise-summarizing",
    "href": "summarize.html#group-wise-summarizing",
    "title": "Summarize",
    "section": "Group-Wise Summarizing",
    "text": "Group-Wise Summarizing\nNow that we’ve covered the %&gt;% operator we can use it to do group-wise summarization! Technically this summarization does not require the pipe but it does inherently have two steps and thus benefits from using the pipe to chain together those technically separate instructions.\nTo summarize by groups we first define our groups using dplyr’s group_by function and then summarize using summarize (also from dplyr). summarize does require you to specify what calculations you want to perform within your groups though it uses similar syntax to dplyr’s mutate function.\n\n\n\nDespite the similarity in syntax between summarize and mutate there are a few crucial differences:\n\nsummarize returns only a single row per group while mutate returns as many rows as are in the original dataframe\nsummarize will automatically remove any columns that aren’t either (1) included in group_by or (2) created by summarize. mutate cannot remove columns so it only creates whatever you tell it to.\n\n\ngroup_by + summarize Example: Summarize within Groups\n\n\n\n\n\n\nExample\n\n\n\nBy using the %&gt;% with group_by and summarize, we can calculate some summarized metric within our specified groups. To begin, let’s find the average bill depth within each species of penguin.\n\n# Begin with the data and a pipe\npenguins %&gt;%\n  # Group by the desired column names\n  dplyr::group_by(species) %&gt;%\n  # And summarize in the way we desire\n  dplyr::summarize(mean_bill_dep_mm = mean(bill_depth_mm, na.rm = TRUE) )\n\n# A tibble: 3 × 2\n  species   mean_bill_dep_mm\n  &lt;fct&gt;                &lt;dbl&gt;\n1 Adelie                18.3\n2 Chinstrap             18.4\n3 Gentoo                15.0\n\n\nNotice how the resulting dataframe only contains one row per value in the group_by call and only includes the grouping column and the column we created (mean_bill_dep_mm)? This reduction in dimensions is an inherent property of summarize and can be intensely valuable but be careful you don’t accidentally remove columns that you want!\n\n\n\n\ngroup_by + summarize Example: Calculate Multiple Metrics\n\n\n\n\n\n\nExample\n\n\n\nLet’s say we want to find multiple summary values for body mass of each species of penguin on each island. To accomplish this we can do the following:\n\n# Begin with the data and a pipe\npenguins %&gt;%\n  # Group by the desired column names\n  dplyr::group_by(species, island) %&gt;%\n  # And summarize in the way we desire\n  dplyr::summarize(\n    # Get average body mass\n    mean_mass_g = mean(body_mass_g, na.rm = TRUE),\n    # Get the standard deviation\n    sd_mass = sd(body_mass_g, na.rm = TRUE),\n    # Count the number of individual penguins of each species at each island\n    n_mass = dplyr::n(),\n    # Calculate standard error from SD divided by count\n    se_mass = sd_mass / sqrt(n_mass) )\n\n# A tibble: 5 × 6\n# Groups:   species [3]\n  species   island    mean_mass_g sd_mass n_mass se_mass\n  &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;   &lt;dbl&gt;  &lt;int&gt;   &lt;dbl&gt;\n1 Adelie    Biscoe          3710.    488.     44    73.5\n2 Adelie    Dream           3688.    455.     56    60.8\n3 Adelie    Torgersen       3706.    445.     52    61.7\n4 Chinstrap Dream           3733.    384.     68    46.6\n5 Gentoo    Biscoe          5076.    504.    124    45.3\n\n\nYou can see that we also invoked the n function from dplyr to return the size of each group. This function reads any groups created by group_by and returns the count of rows in the dataframe for each group level.\nJust like mutate, summarize will allow you to create as many columns as you want. So, if you want metrics calculated within your groups, you only need to define each of them within the summarize function.\n\n\n\n\nChallenge: summarize\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing what we’ve covered so far, find the average flipper length in each year (regardless of any other grouping variable).",
    "crumbs": [
      "Modules",
      "Summarize"
    ]
  },
  {
    "objectID": "summarize.html#grouping-cautionary-note",
    "href": "summarize.html#grouping-cautionary-note",
    "title": "Summarize",
    "section": "Grouping Cautionary Note",
    "text": "Grouping Cautionary Note\ngroup_by can be extremely useful in summarizing a dataframe or creating a new column without losing rows but you need to be careful. Objects created with group_by “remember” their groups until you change the groups or use the function ungroup from dplyr.\nLook at how the output of a grouped data object tells you the number of groups in the output (see beneath this code chunk).\n\npenguins %&gt;%\n  dplyr::group_by(species, island) %&gt;%\n  dplyr::summarize(penguins_count = dplyr::n())\n\n# A tibble: 5 × 3\n# Groups:   species [3]\n  species   island    penguins_count\n  &lt;fct&gt;     &lt;fct&gt;              &lt;int&gt;\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n\n\nThis means that all future uses of that pipe will continue to use the grouping established to create the “penguins_count” column. We can stop this by doing the same pipe, but adding ungroup after we’re done using the grouping established by group_by.\n\npenguins %&gt;%\n  dplyr::group_by(species, island) %&gt;%\n  dplyr::summarize(penguins_count = dplyr::n()) %&gt;%\n  dplyr::ungroup()\n\n# A tibble: 5 × 3\n  species   island    penguins_count\n  &lt;fct&gt;     &lt;fct&gt;              &lt;int&gt;\n1 Adelie    Biscoe                44\n2 Adelie    Dream                 56\n3 Adelie    Torgersen             52\n4 Chinstrap Dream                 68\n5 Gentoo    Biscoe               124\n\n\nSee? We calculated with our desired groups but then dropped the grouping structure once we were finished with them. Note also that if you use group_by and do some calculation then re-group by something else by using group_by again, the second use of group_by will not be affected by the first. This means that you only need one ungroup per pipe.",
    "crumbs": [
      "Modules",
      "Summarize"
    ]
  },
  {
    "objectID": "reshape.html",
    "href": "reshape.html",
    "title": "Reshape",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nContrast “long” data with “wide” data\n\nUse tidyr’s pivot_wider and pivot_longer functions to reshape data",
    "crumbs": [
      "Modules",
      "Reshape"
    ]
  },
  {
    "objectID": "reshape.html#module-learning-objectives",
    "href": "reshape.html#module-learning-objectives",
    "title": "Reshape",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nContrast “long” data with “wide” data\n\nUse tidyr’s pivot_wider and pivot_longer functions to reshape data",
    "crumbs": [
      "Modules",
      "Reshape"
    ]
  },
  {
    "objectID": "reshape.html#defining-shape",
    "href": "reshape.html#defining-shape",
    "title": "Reshape",
    "section": "Defining “Shape”",
    "text": "Defining “Shape”\nBefore talking about how to reshape your data between wide and long format, let’s talk about what “shape” means in reference to data. Fundamentally, “long” data are data with more rows than columns while “wide” data tend to have more columns than rows.\nFor example, in community ecology a “wide” dataframe could have each row being a site that researchers visited while each column could be a different species where the value in the row is the number of individuals of that species at that site. On the other hand, the penguins dataframe we’ve been working with so far is in “long” format because it has one row per penguin and multiple penguins are stacked up.\nBoth wide and long format data can be useful in certain contexts and it is sometimes most intuitive to reshape data from one form to the other (and sometimes back again to the original form!).",
    "crumbs": [
      "Modules",
      "Reshape"
    ]
  },
  {
    "objectID": "reshape.html#reshaping-data",
    "href": "reshape.html#reshaping-data",
    "title": "Reshape",
    "section": "Reshaping Data",
    "text": "Reshaping Data\nThe tidyr package contains the intuitively-named pivot_wider and pivot_longer for doing exactly this reshaping.\nTo help demonstrate these two functions, let’s begin by summarizing our dataframe to make changing the shape of the dataframe more visible than it would be with the full dataframe. For example, let’s calculate the average bill length of each penguin species on each island.\n\n# Begin by naming our new data and the data they come from\npenguins_simp &lt;- penguins %&gt;%\n  # Now group by species and island\n  dplyr::group_by(species, island) %&gt;%\n  # Calculate average bill length\n  dplyr::summarize(avg_bill_length_mm = mean(bill_length_mm, na.rm = TRUE)) %&gt;%\n  # And don't forget to ungroup!\n  dplyr::ungroup()\n\n# And this is what we're left with:\npenguins_simp\n\n# A tibble: 5 × 3\n  species   island    avg_bill_length_mm\n  &lt;fct&gt;     &lt;fct&gt;                  &lt;dbl&gt;\n1 Adelie    Biscoe                  39.0\n2 Adelie    Dream                   38.5\n3 Adelie    Torgersen               39.0\n4 Chinstrap Dream                   48.8\n5 Gentoo    Biscoe                  47.5\n\n\nGreat! We can use this smaller data object to demonstrate reshaping more clearly. Let’s begin with an example for pivot_wider.\n\npivot_wider Example: Reshaping to Wide Format\n\n\n\n\n\n\nExample\n\n\n\npivot_wider takes long format data and reshapes it into wide format.\n\n\n\nLet’s say that we want to take that data object and reshape it into wide format so that each island is a column and each species of penguin is a row. The contents of each cell then are going to be the average bill length values that we just calculated.\n\n# Begin by naming the objects\npenguins_wide &lt;- penguins_simp %&gt;%\n  # And now we can pivot wider with `pivot_wider`!\n  tidyr::pivot_wider(names_from = island,\n                     values_from = avg_bill_length_mm )\n\n# Take a look!\npenguins_wide\n\n# A tibble: 3 × 4\n  species   Biscoe Dream Torgersen\n  &lt;fct&gt;      &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 Adelie      39.0  38.5      39.0\n2 Chinstrap   NA    48.8      NA  \n3 Gentoo      47.5  NA        NA  \n\n\nGreat! We now have each island as a column, each row is a penguin species, and the bill length measurement we took is included in each cell. Note that in this specific case this makes the number somewhat ambiguous so we might want to use dplyr’s select or the more specific rename to change the island names to be clearer that those values are bill lengths in milimeters.\n\n\n\n\npivot_longer Example: Reshaping to Long Format\n\n\n\n\n\n\nExample\n\n\n\nNow that we have a small wide format data object, we can feed it to pivot_longer and reshape our data into long format! pivot_longer has very similar syntax except that with pivot_longer you need to tell the function which columns should be reshaped.\npivot_wider on the other hand knows which columns to move around because you manually specify them in the “names_from” and “values_from” arguments.\n\n\n\n\n# Begin with our wide data\npenguins_wide %&gt;%\n  # And reshape back into long format\n  pivot_longer(cols = -species,\n               names_to = \"island_name\",\n               values_to = \"mean_bill_length_mm\" )\n\n# A tibble: 9 × 3\n  species   island_name mean_bill_length_mm\n  &lt;fct&gt;     &lt;chr&gt;                     &lt;dbl&gt;\n1 Adelie    Biscoe                     39.0\n2 Adelie    Dream                      38.5\n3 Adelie    Torgersen                  39.0\n4 Chinstrap Biscoe                     NA  \n5 Chinstrap Dream                      48.8\n6 Chinstrap Torgersen                  NA  \n7 Gentoo    Biscoe                     47.5\n8 Gentoo    Dream                      NA  \n9 Gentoo    Torgersen                  NA  \n\n\nTwo quick things to note here:\n\nFirst, pivot_longer included the cells that were NA in the wide version of the data.\n\nThis default behavior is really nice so that you don’t lose any cells implicitly (though you can always filter them out if you don’t want them!).\n\nSecond, you’ll note that in the “cols” argument I only told pivot_longer to not include the “species” column using the same notation you could use for the select function in the dplyr package.\n\nThis is very handy because it lets us write really concise values in the “cols” argument and the default becomes “everything except what was specified”.\nNote that we could have also said cols = Biscoe, Dream, Torgersen and achieved the same reshaping of the data.\n\n\n\n\n\n\nChallenge: Reshaping\n\n\n\n\n\n\nYour Turn!\n\n\n\nThe code below creates a data object that includes the flipper length of all Adelie penguins; what code would you add to reshape the data so that each sex is a column with flipper lengths in the cells?\n\npenguins %&gt;%\n  # Keep only Adelie penguins of known sex\n  dplyr::filter(species == \"Adelie\" & !is.na(sex)) %&gt;%\n  # Calculate the average flipper length by island and sex\n  dplyr::group_by(island, sex) %&gt;%\n  dplyr::summarize(avg_flipper_length_mm = mean(flipper_length_mm, na.rm = TRUE)) %&gt;%\n  # Ungroup (good practice to include this step!)\n  dplyr::ungroup()\n\n# A tibble: 6 × 3\n  island    sex    avg_flipper_length_mm\n  &lt;fct&gt;     &lt;fct&gt;                  &lt;dbl&gt;\n1 Biscoe    female                  187.\n2 Biscoe    male                    190.\n3 Dream     female                  188.\n4 Dream     male                    192.\n5 Torgersen female                  188.\n6 Torgersen male                    195.",
    "crumbs": [
      "Modules",
      "Reshape"
    ]
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "SciComp Workshop - Coding in the Tidyverse",
    "section": "",
    "text": "When contributing to this project, please see our team’s primary contributing guidelines document and follow the guidance there."
  },
  {
    "objectID": "CONTRIBUTING.html#contributing-guidelines",
    "href": "CONTRIBUTING.html#contributing-guidelines",
    "title": "SciComp Workshop - Coding in the Tidyverse",
    "section": "",
    "text": "When contributing to this project, please see our team’s primary contributing guidelines document and follow the guidance there."
  },
  {
    "objectID": "visualize.html",
    "href": "visualize.html",
    "title": "Visualize",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nCreate a baseline plot with ggplot2’s ggplot function along with the aes helper function.\nAdd desired geometries to your baseline plot with the geom_... family of functions\nExplain the advantage of using the + operator to add together multiple plot elements\nUse ggplot2’s labs and scale_fill_manual helper functions to customize your plot’s labels and colors\nDifferentiate aes’ fill and color arguments\nGenerate separate plots based on grouping variable(s) with ggplot2’s facet_grid function\nDesign a custom format for your plots using ggplot2’s theme function",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "visualize.html#module-learning-objectives",
    "href": "visualize.html#module-learning-objectives",
    "title": "Visualize",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nCreate a baseline plot with ggplot2’s ggplot function along with the aes helper function.\nAdd desired geometries to your baseline plot with the geom_... family of functions\nExplain the advantage of using the + operator to add together multiple plot elements\nUse ggplot2’s labs and scale_fill_manual helper functions to customize your plot’s labels and colors\nDifferentiate aes’ fill and color arguments\nGenerate separate plots based on grouping variable(s) with ggplot2’s facet_grid function\nDesign a custom format for your plots using ggplot2’s theme function",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "visualize.html#ggplot2-overview",
    "href": "visualize.html#ggplot2-overview",
    "title": "Visualize",
    "section": "ggplot2 Overview",
    "text": "ggplot2 Overview\nWhile the bulk of the Tidyverse is focused on modifying a given data object, ggplot2 is also a package in the Tidyverse that is more concerned with–intuitively enough–plotting tidy data. ggplot2 does share some syntax with the functions and packages that we’ve discussed so far but it also introduces some new elements that we’ll discuss as we encounter them.",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "visualize.html#creating-a-plot",
    "href": "visualize.html#creating-a-plot",
    "title": "Visualize",
    "section": "Creating a Plot",
    "text": "Creating a Plot\nTo create the foundation for your plot, we’ll use the ggplot function (note that the package is ggplot2 while the function name lacks the “2”). This function allows you to globally define the data object you’re using as well as which variable(s) should be mapped to x and y axes as well as aesthetic parameters–for example, which groups outline or fill color should be inherited from, etc. The ggplot function relies on an aesthetics helper function named aes. We’ll give ggplot the data name and aes, while we’ll pass all relevant variables to aes directly. This may be easier to follow once we’ve covered an example so let’s do that now!\n\n\n\n\n\n\nExample\n\n\n\nJust like the preceding chapters, let’s use the penguins dataset to demonstrate this plot. Let’s create the foundation of a graph that has year on the y-axis and body_mass_g in the x-axis.\nThe ggplot function wants both a data and mapping argument that we’ll specify here for clarity but will exclude going forward. mapping expects the aes function that in turn defines all your variable placements.\n\nggplot(data = penguins, mapping = aes(x = year, y = body_mass_g))\n\n\n\n\n\n\n\n\nIt may not look like it, but this was successful! The ggplot function creates the first “layer” of the plot including raw axis titles and tick marks but when creating a plot with the ggplot2 package, choosing which plot type is actually done with a separate class of functions called “geometries”.",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "visualize.html#choosing-a-plot-type",
    "href": "visualize.html#choosing-a-plot-type",
    "title": "Visualize",
    "section": "Choosing a Plot Type",
    "text": "Choosing a Plot Type\nNow that we have a baseline plot, we can add desired geometries using the geom_... family of functions. Broadly speaking, there is one geom_... for every possible way of plotting your data. Want to make a scatter plot? Use geom_point. Bar plot? geom_bar. Add a best-fit line? geom_smooth. When you first begin making plots with ggplot2 you will likely have to Google which geom_... you want (that was certainly what the creators of this workshop did when we started out!) but over time you’ll remember them more and more clearly.\n\nGeometry Aside No. 1 - Adding Plot Elements\nYou may have noticed that the core plot is built with ggplot and aes but each subsequent component is added with one of the geom_... functions and realized the gap we haven’t talked about yet: how do we combine these separate lines of code? The answer is part of what makes ggplot different from the rest of the Tidyverse. In the rest of the Tidyverse we chain together multiple lines of code with the %&gt;% operator, however, in ggplot2 we use + to combine separate lines of code.\nThis has a distinct advantage that we’ll discuss later but we’ll use the + in the following example to show its use.\n\n\ngeom_... Example: Adding a Geometry\n\n\n\n\n\n\nExample\n\n\n\nLet’s re-create our year by body_mass_g plot but let’s make it a scatter plot by adding geom_point.\n\nggplot(data = penguins, mapping = aes(x = year, y = body_mass_g)) +\n  geom_point()\n\n\n\n\n\n\n\n\nBecause aes gets all of the variable mapping information, we don’t need to give anything to geom_point! This makes adding multiple geometries much easier than if we had to re-specify the variables separately in every geometry!\n\n\n\n\ngeom_... Example: Adding Multiple Geometries\n\n\n\n\n\n\nExample\n\n\n\nLet’s add a best-fit line to this graph to demonstrate how multiple geometries are added.\n\nggplot(data = penguins, mapping = aes(x = year, y = body_mass_g)) +\n  geom_point() +\n  geom_smooth()\n\n\n\n\n\n\n\n\nNot a terribly informative graph but the code aptly demonstrates how several geometries can be layered.\n\n\n\n\nGeomtery Aside No. 2 - Order Matters\nThe heading says it all: order matters! The order that you add geom_...s to your plot (using +) determines which geometries are “above” or “in front of” others. This is a desirable behavior for plots with multiple geometries but is something to keep in mind! Let’s cover an example to clarify this.\n\n\ngeom_... Example: Order\n\n\n\n\n\n\nExample\n\n\n\nLet’s say we want to make a ggplot of bill depth within each penguin species and we want both a boxplot and the points that make up the boxplot. This involves using both the geom_point and geom_boxplot geometries but order will be crucial! To demonstrate our point better, we’ll also add a new argument to our aes: fill. fill defines which variable should be used to fill in open spaces (like bar or box plots). Let’s create our plot!\n\nggplot(penguins, aes(x = species, y = bill_depth_mm, fill = species)) +\n  geom_point() +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nOur plot has all the right elements, but the box plots are covering up the points between the ends of the box (the 25th and 75th quartiles). If we change the geometry order we’ll get our points “in front of” the box plots.\n\nggplot(penguins, aes(x = species, y = bill_depth_mm, fill = species)) +\n  geom_boxplot() +\n  geom_point()\n\n\n\n\n\n\n\n\nNow our points can be seen even when they overlap with the box plot. Note that the order of geometries doesn’t affect any overlap in either the x or y axis. In our above plot you’ll see that our points are so densely stacked that it is difficult to see the whiskers’ extent. We must change geometries in order to fix overlap issues like this. Fortunately, we can use geom_jitter instead of geom_point to make a scatter plot where all points are jittered in the x-axis to make them easier to see.\n\nggplot(penguins, aes(x = species, y = bill_depth_mm, fill = species)) +\n  geom_boxplot() +\n  # The width argument lets us specify how far apart (in the x-axis) we want points to jitter\n  geom_jitter(width = 0.25)\n\n\n\n\n\n\n\n\nGreat! Now we can see both the points and the box plots because we’ve achieved (1) the order of geometries and (2) the type of geometries that we need in this case.\n\n\n\n\nChallenge: Geometries\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing ggplot2, create a scatter plot of bill_depth_mm against body_mass_g.",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "visualize.html#advantage-of-the",
    "href": "visualize.html#advantage-of-the",
    "title": "Visualize",
    "section": "Advantage of the +",
    "text": "Advantage of the +\nWhen we first introduced the + for adding together multiple plot elements we said that it had a key advantage but were vague about what exactly that benefit was. The + allows you to build plots stepwise by adding elements to an object. This can be extremely useful when you’re experimenting with a plot as you could make several different objects, each with increasingly more plot elements, and allow all of them to inherit the same fundamental architecture.\nFor users who are writing their own functions, the + allows you to build plots using conditions specified by arguments. Say you want to write a function that always makes the same type of ggplot but you want to allow users to choose whether a best-fit line is added. Because of the + you can do exactly this!\nLet’s cover a quick example of the value of stepwise plot creation.\n\nStepwise Plot Addition Example\n\n\n\n\n\n\nExample\n\n\n\nLet’s create a plot of bill length against bill depth and color the points by penguin species. First, we create the foundation of our plot without any geometries and assign it to an object using the &lt;- operator.\n\nplot_v1 &lt;- ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species))\nplot_v1\n\n\n\n\n\n\n\n\nNow let’s add points to this blank plot using geom_point (in this case we do not want geom_jitter because it changes the x-position of points).\n\nplot_v2 &lt;- plot_v1 + \n  geom_point()\nplot_v2\n\n\n\n\n\n\n\n\nNow we can further add a linear regression line (geom_smooth(method = \"lm\")) for each species’ bill depth vs. length relationship. Because we colored by species earlier, geom_smooth will automatically create separate regression lines! Pretty cool, right?\n\nplot_v3 &lt;- plot_v2 + \n  geom_smooth(method = \"lm\")\nplot_v3\n\n\n\n\n\n\n\n\nGreat! We could have added the ggplot and geom_point and geom_smooth lines together at the same time but the + allows us to build graphics step-by-step if we so desire.",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "visualize.html#customizing-plots",
    "href": "visualize.html#customizing-plots",
    "title": "Visualize",
    "section": "Customizing Plots",
    "text": "Customizing Plots\nThere are too many helper functions included in ggplot2 to cover them all here but we can cover two that you may find particularly helpful: labs and scale_fill_manual.\n\nCustomizing - Labels\nlabs is ggplot2’s one-stop shop solution to customizing your axis labels and plot title. Add labs in the same way you would add a geometry to add custom axis labels to your plot. This is especially useful if your column names are highly abbreviated or otherwise difficult for those outside of your group to interpret.\n\n\nlabs Example: Adding Labels\n\n\n\n\n\n\nExample\n\n\n\nLet’s make a plot of the number of penguins per island per species with more informative axis labels and a plot title. We’ll need to calculate that quickly but we can leverage the tools we practiced in the “Summarize” chapter to do that.\n\n# Count penguins\npenguin_count &lt;- penguins %&gt;%\n  dplyr::group_by(species, island) %&gt;%\n  dplyr::summarize(total = dplyr::n()) %&gt;%\n  dplyr::ungroup()\n\n# Take a look at that object\ndplyr::glimpse(penguin_count)\n\nRows: 5\nColumns: 3\n$ species &lt;fct&gt; Adelie, Adelie, Adelie, Chinstrap, Gentoo\n$ island  &lt;fct&gt; Biscoe, Dream, Torgersen, Dream, Biscoe\n$ total   &lt;int&gt; 44, 56, 52, 68, 124\n\n\nNow that we have that object, let’s make a bar plot of penguins on each island and let’s color by penguin species.\n\nggplot(penguin_count, aes(x = island, y = total, fill = species)) +\n  # `stat` argument defines whether you've already done the calculation or you want `ggplot` to try to do it itself\n  geom_bar(stat = 'identity') +\n  labs(x = \"Island Name\",\n       y = \"Penguins Measured\",\n       title = \"Number Penguins Counted per Island and Species\")\n\n\n\n\n\n\n\n\nWe now have much more human-readable axis labels and an informative title! labs can also be used to add a subtitle, caption, or even alt text (alternative text is special text embedded in an image that is useful for people who require a screen reader to describe visual elements). See ?labs for more information on the other labels it controls.\n\n\n\n\nCustomizing - Using Custom Colors\nAs we’ve progressed through this training you may have noticed the classic ggplot2 default colors (the first three are a mild red, blue, and green). It is often the case however that we want to choose our own colors; this is where scale_fill_manual becomes needed.\nThis function is added in the same way that the geom_... and labs functions are added and requires a vector of the colors that you want to use instead of the defaults. There are two key conditions to keep in mind when specifying your colors. First, you must supply as many colors as there are groups to color by; ggplot2 will not fill in defaults if you supply too few colors and won’t guess which to drop if you give too many. Second, the order that you provide colors in must be correct OR you must “name” each color to assign it to a specific group. To “name” the color, use the following syntax: c(groupA = color1, groupB = color2, .... Order can be a simple vector but it is often nice to be explicit about which group should be which color.\nLet’s return to our bar plot above and change the colors used for our bar plot.\n\n\nscale_fill_manual Example: Specify Fill\n\n\n\n\n\n\nExample\n\n\n\nLet’s re-create the plot from the previous example and specify the colors manually using scale_fill_manual\n\n# Create the plot\nggplot(penguin_count, aes(x = island, y = total, fill = species)) +\n  geom_bar(stat = 'identity') +\n  # Specify labels\n  labs(x = \"Island Name\", y = \"Penguins Measured\") +\n  # Choose colors!\n  scale_fill_manual(values = c(\"red\", \"orange\", \"yellow\"))\n\n\n\n\n\n\n\n\nTwo quick notes before we move on:\n\nYou can use “hexadecimal codes” for colors (sort of a machine-readable way of specifying colors) in this function. We find the website colorbrewer2.org particularly useful because it groups colors into palettes and includes a “colorblind safe” check box that limits your options to only those that will be accessible to all viewers. You can also download the RColorBrewer package to easily incorporate its many color palettes into your visualizations!\nFeel free to check out NCEAS’ R color cheatsheet for more color options.\n\n\n\n\n\nCustomizing - color versus fill\nOne nuance of ggplot2 aesthetics that we should cover before continuing is the difference between “color” and “fill”. If used in the aes function, both of these at first glance seem to dictate what we might think of as “plot color.” In the example above, we used scale_fill_manual to specify the color of the bars in our bar plot.\nPut clearly: ggplot2 defines “fill” versus “color” as follows:\n\nfill = controls color inside of a hollow shape\ncolor = controls color on the outside of a hollow shape or the entire color of a solid shape\n\nFrom ggplot2’s point of view, a solid shape is essentially a shape that is all outline and both real outlines and non-hollow shapes fall under color’s jurisdiction\n\n\nLet’s make some example plots to demonstrate this distinction.\n\n\n\n\n\n\nExample\n\n\n\nLet’s make a boxplot of bill_length_mm across penguin species and set fill to species.\n\nggplot(penguins, aes(x = species, y = bill_length_mm,\n                     fill = species)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nNotice how the interior of the boxes is colored by species? Watch what happens when we make the same plot again but change fill = to color = in the aes function:\n\nggplot(penguins, aes(x = species, y = bill_length_mm,\n                     color = species)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nSee how the interior of the box plots now defaults to white but the outline edges become colored by species? Let’s demonstrate this again with a solid object to show fill versus color in another context.\nLet’s create a scatterplot of bill_length_mm by bill_depth_mm and color by species\n\nggplot(penguins, aes(x = bill_depth_mm, y = bill_length_mm,\n                     color = species)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThe default point shape for a ggplot2 scatterplot is a solid dot so the points are now fully colored by species (see ?pch for other point options). What if we changed color = to fill = though?\n\nggplot(penguins, aes(x = bill_depth_mm, y = bill_length_mm,\n                     fill = species)) +\n  geom_point()\n\n\n\n\n\n\n\n\nInterestingly, ggplot2 knows that you’re trying to differentiate by species so it still returns a legend but unfortunately all three species’ points defaulted to black so we can’t see the difference! If we change the points to be hollow however…\n\nggplot(penguins, aes(x = bill_depth_mm, y = bill_length_mm,\n                     fill = species)) +\n  geom_point(shape = 21)\n\n\n\n\n\n\n\n\nWe now get our points filled with the correct color with a black outline to each point!\nIf you ever try to manually specify one or the other and your plot looks the same, chances are you’re mis-specifying color for fill or vice versa. Double check that and you will often resolve the issue\n\n\n\n\nChallenge: Customizing\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing ggplot2, create a scatter plot of bill_depth_mm against body_mass_g and where the points are colored based on the sex of the penguin. Make female penguins’ points red and male penguins’ points blue. Also, give both axes manually-specified titles (i.e., not the raw column names!).",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "visualize.html#separating-plots-by-a-variable",
    "href": "visualize.html#separating-plots-by-a-variable",
    "title": "Visualize",
    "section": "Separating Plots by a Variable",
    "text": "Separating Plots by a Variable\nSometimes it is useful to create a plot but separate out the data by one of the columns. ggplot2 includes the facet_... family of functions to accomplish this. faceting a plot creates several panels that have the same labels and data but separated by whatever variable(s) you give to the facet_... function in question.\n\nfacet_grid Example\n\n\n\n\n\n\nExample\n\n\n\nLet’s return to our multi-colored bill length vs. bill depth plot to demonstrate faceting in action. We’ll create the same plot but this time we’ll facet by island so that the penguins of each island are included in separate panes.\nThe syntax of facet_grid is as follows: [column for columns of plots] ~ [column for rows of plots]. If you only want rows or columns of your plot panes, replace that side of the ~ with a period.\n\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  # Let's also add better axis labels\n  labs(x = \"Bill Length (mm)\", y = \"Bill Depth (mm)\") +\n  # Now facet by island\n  facet_grid(. ~ island)\n\n\n\n\n\n\n\n\nNote that the values within island that make up each pane are included in the dark gray bar at the top of each pane. This behavior is automatic and makes your separated plots much more interpretable.\n\n\n\n\nChallenge: facet_grid\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing the plot you created for the previous challenge (bill_depth_mm vs. body_mass_g and color = sex, etc.), facet by species of penguin. Note that you can choose whether you want your plot panels stacked vertically or horizontally.",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "visualize.html#changing-thematic-properties",
    "href": "visualize.html#changing-thematic-properties",
    "title": "Visualize",
    "section": "Changing Thematic Properties",
    "text": "Changing Thematic Properties\nIn all of our preceding examples the plots have a characteristic ggplot2 “feel” where they all have gray backgrounds with white grid lines of varying thickness depending on whether they are minor or major. If color or fill is specified in aes the legend is on the right and in all plots the axis labels and tick marks are (in our opinion) a very small font size.\nggplot2 placed all of the power to modify any of these parameters into a single, comprehensive function: theme. theme allows users to specify nearly any formatting component and modify it as they desire. Just like the geom_... functions, Google will very much be your friend as you try to remind yourself about the breadth of possibility within theme but over time you will become more comfortable and confident!\nLet’s cover an example to demonstrate a few components of theme.\n\ntheme Example: Manual Specification\n\n\n\n\n\n\nExample\n\n\n\nLet’s create a plot of bill length versus flipper length and colored by penguin species.\n\ncore_plot &lt;- ggplot(penguins, aes(x = flipper_length_mm, y = bill_length_mm,\n                                  color = species)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  # Let's also add better axis labels\n  labs(x = \"Flipper Length (mm)\", y = \"Bill Length (mm)\")\n\ncore_plot\n\n\n\n\n\n\n\n\nNow that we have this plot, let’s change three things using theme: 1. Increase axis text size 2. Increase axis title text size 3. Move the legend into the bottom right of the plot\nTo accomplish this, we’ll add a theme to the core_plot object that we created above and specify each of those changes within that function.\n\ncore_plot +\n  # Add `theme` to the plot\n  theme(\n    # Tell it the X/Y coordinates of the legend\n    legend.position = c(0.9, 0.15),\n    # Now change the text size of the axis ticks and labels\n    axis.title = element_text(size = 18),\n    axis.text = element_text(size = 14) )\n\n\n\n\n\n\n\n\nNote that for certain parameters, you must also specify one of the element_... family of functions. element_text governs all things related to text (i.e., size, font, etc.) while element_rect changes things related to background boxes of plot components. There are other element_... functions that you’ll encounter as you use Google and Stack Overflow (a coding help website Google will frequently identify when you search for error explanations) so rest assured that you’ll be able to find support documentation for these when you need it.\n\n\n\n\ntheme Example: Pre-Packaged Themes\nIf that all seemed pretty involved, don’t worry! ggplot2 comes with several theme_... functions that are pre-built and modify a lot of these parameters in desirable ways without necessitating you doing a deep dive into Google. For instance, theme_bw or theme_classic are both great options that we’ll demonstrate below.\n\n\n\n\n\n\nExample\n\n\n\nLet’s re-use the core_plot object we built above to quickly demonstrate theme_bw and theme_classic. You’ve likely seen the default ggplot2 theme ad nauseam at this point but let’s show it one more time for comparative purposes.\n\ncore_plot\n\n\n\n\n\n\n\n\nNow let’s call the same plot but add theme_bw to it.\n\ncore_plot +\n  theme_bw()\n\n\n\n\n\n\n\n\nNot bad! Finally, let’s check out theme_classic.\n\ncore_plot + \n  theme_classic()\n\n\n\n\n\n\n\n\nEven better! If you’d like, you can use a pre-built theme and specify additional elements yourself. Let’s add the theme content we came up with in the previous example to the theme_classic plot.\n\ncore_plot + \n  # Add the 'classic' theme\n  theme_classic() +\n  # As before, change the legend position and axis text size\n  theme(legend.position = c(0.9, 0.15),\n        axis.title = element_text(size = 18),\n        axis.text = element_text(size = 14) )\n\n\n\n\n\n\n\n\nNow that is looking publication-quality! One quick note though: whichever theme specification is last “wins”. This means that if you have a theme call that sets font size to 14 and then add a second theme beneath it that sets font size to 30, the font size of your plot will be 30. This is part of why you can add pre-built themes and your own custom modifications together but is good to keep in mind if you’re sure your custom theme is specified correctly but isn’t showing up in your plot.\n\n\n\n\nChallenge: theme\n\n\n\n\n\n\nYour Turn!\n\n\n\nUsing the plot you created for the previous challenge (bill_depth_mm vs. body_mass_g and color = sex, etc.), (1) add the theme_bw pre-built theme, (2) increase the axis title size to 16, and (3) move the legend into the top left of the plot.\n\n\n\n\nCombining theme and +\nWe discussed the strengths of ggplot2’s + operator earlier but it bears repeating here now that we’ve covered theme. An extremely helpful combination of these principles allows you to save all of your theme editing into an object and then add that object to all the different plots you make for the project! This would guarantee that all of your plots have the same format without you needing to re-write that formatting for every plot. We’ll demonstrate briefly below.\n\n\nExample: theme & +\n\n\n\n\n\n\nExample\n\n\n\nLet’s begin by defining our theme that we want all plots to use. For simplicity’s sake, let’s use the theme code outlined in the previous example.\n\n# Begin with `theme_classic` and then add on our custom modifications\nmy_theme &lt;- theme_classic() +\n  # As before, we're moving the legend and increasing axis font size\n  theme(legend.position = c(0.7, 0.8),\n        axis.title = element_text(size = 18),\n        axis.text = element_text(size = 14) )\n\nNow we can make a handful of plots and add the my_theme object to each of them!\n\nggplot(penguins, aes(x = year, y = bill_depth_mm, color = sex)) +\n  geom_jitter(width = 0.1) +\n  labs(x = \"Year\", y = \"Bill Depth (mm)\",\n       title = \"Bill Depth x Year x Sex\") +\n  my_theme\n\n\n\n\n\n\n\n\n\nggplot(penguins, aes(x = year, y = bill_length_mm, color = island)) +\n  geom_jitter(width = 0.1) +\n  labs(x = \"Year\", y = \"Bill Length (mm)\",\n       title = \"Bill Length x Year x Island\") +\n  my_theme\n\n\n\n\n\n\n\n\n\nggplot(penguins, aes(x = year, y = flipper_length_mm, color = species)) +\n  geom_jitter(width = 0.1) +\n  labs(x = \"Year\", y = \"Flipper Length (mm)\",\n       title = \"Flipper Length x Year x Species\") +\n  my_theme\n\n\n\n\n\n\n\n\nThis can be a great way of making your figure creation process dramatically more efficient when it becomes time to shift from exploratory plots to publication-quality figures!",
    "crumbs": [
      "Modules",
      "Visualize"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "This workshop provides an overview of many of the packages included in the Tidyverse suite of packages for the R programming language. The Tidyverse is a veritable universe of tools though that no single workshop could hope to cover so we are focusing here on an introductory approach that focuses primarily on some fundamentals to tidying data in R. We are always happy to improve workshop content so please don’t hesitate to post an Issue on our GitHub repository if you see clear areas for improvement!\n\nTo maximize the value of this workshop to you, we recommend that you take the following steps before the day of the workshop. If anything is unclear, feel free to reach out to us; our contact information can be found here",
    "crumbs": [
      "Workshop Home"
    ]
  },
  {
    "objectID": "index.html#workshop-preparation",
    "href": "index.html#workshop-preparation",
    "title": "Overview",
    "section": "Workshop Preparation",
    "text": "Workshop Preparation\nFor those of you with a dedicated IT team that has sole power to install software on your computer: you may need to contact them before the workshop to do the installation bits of the prep steps we outline below.\n\n1. Install R\nInstall R. If you already have R, check that you have at least version 4.0.0 by running the following code:\n\nversion$version.string\n\nIf your version starts with a 3 (e.g., the above code returns “R version 3…”), please update R to make sure all packages behave as expected.\n\n\n2. Install RStudio\nOnce you have R (ver. ≥4.0), install RStudio. If you already have RStudio installed, you may want to make sure that you’re using a recent version to take advantage of some quality of life improvements that are broadly useful.\n\n\n3. Install Some R Packages\nInstall the tidyverse and palmerpenguins R packages using the following code:\n\ninstall.packages(\"librarian\")\nlibrarian::shelf(tidyverse, palmerpenguins)\n\nPlease run the above code even if you already have these packages to update these packages and ensure that your code aligns with the examples and challenges introduced during the workshop.\n\n\n4. Celebrate!\nAfter following all the previous preparation steps, your setup should now be complete.",
    "crumbs": [
      "Workshop Home"
    ]
  },
  {
    "objectID": "index.html#example-data---penguins",
    "href": "index.html#example-data---penguins",
    "title": "Overview",
    "section": "Example Data - Penguins",
    "text": "Example Data - Penguins\nThe data we’ll be using for this workshop comes from the palmerpenguins package, maintained by Allison Horst. The “penguins” dataset from this package contains size measurements for adult foraging penguins near Palmer Station, Antarctica. Data were collected and made available by Dr. Kristen Gorman and the Palmer Station Long Term Ecological Research (LTER) Program. Let’s take a look at it!\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nThe “penguins” dataset has 344 rows and 8 columns.\nThe columns are as follows:\n\nspecies: a factor denoting penguin species (Adélie, Chinstrap and Gentoo)\nisland: a factor denoting island in Palmer Archipelago, Antarctica (Biscoe, Dream or Torgersen)\nbill_length_mm: a number denoting bill length (millimeters)\nbill_depth_mm: a number denoting bill depth (millimeters)\nflipper_length_mm: an integer denoting flipper length (millimeters)\nbody_mass_g: an integer denoting body mass (grams)\nsex: a factor denoting penguin sex (female, male)\nyear: an integer denoting the study year (2007, 2008, or 2009)\n\nThis dataset is an example of tidy data, which means that each variable is in its own column and each observation is in its own row. Generally speaking, functions from packages in the Tidyverse expect tidy data though they can be used in some cases to help get data into tidy format! Regardless, the penguins dataset is what we’ll use for all examples in this workshop so be sure that you install the palmerpenguins R package. The examples on this page were adapted from Allison Horst’s dplyr tutorial!",
    "crumbs": [
      "Workshop Home"
    ]
  },
  {
    "objectID": "index.html#websites-to-visit",
    "href": "index.html#websites-to-visit",
    "title": "Overview",
    "section": "Websites to Visit",
    "text": "Websites to Visit\n\nSupplemental Material\nWhile not technically necessary to attend the workshop, if you’d like you can see the content that created the workshop website you are viewing by visiting our GitHub repository here.\nAlso, check out NCEAS’ Learning Hub for a complete list of workshops and trainings offered by NCEAS.",
    "crumbs": [
      "Workshop Home"
    ]
  },
  {
    "objectID": "join.html",
    "href": "join.html",
    "title": "Join",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDifferentiate dplyr’s various join functions from each other\nUse dplyr’s left_join, right_join, inner_join, full_join, and anti_join functions to manipulate two dataframes",
    "crumbs": [
      "Modules",
      "Join"
    ]
  },
  {
    "objectID": "join.html#module-learning-objectives",
    "href": "join.html#module-learning-objectives",
    "title": "Join",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDifferentiate dplyr’s various join functions from each other\nUse dplyr’s left_join, right_join, inner_join, full_join, and anti_join functions to manipulate two dataframes",
    "crumbs": [
      "Modules",
      "Join"
    ]
  },
  {
    "objectID": "join.html#combining-data",
    "href": "join.html#combining-data",
    "title": "Join",
    "section": "Combining data",
    "text": "Combining data\nNow that we know how to manipulate a single dataframe, how do we manipulate multiple dataframes? If we have multiple sources of data and we want to combine them together into one dataframe or table, we can join them through any shared column(s)! Data you’ll be joining can be called “relational data”, because there is some kind of relationship between the dataframes that you’ll be leveraging. In the Tidyverse, combining data that has a relationship is called “joining”. Let’s look at some of dplyr’s many join functions!\nIn each of the following join functions, you provide two dataframes, the one you arbitrarily provide first is called the “left” dataframe while the other is called the “right” dataframe. This is important because each of the different join functions brings the columns from one of the dataframes into the other depending on (1) which dataframe is left and which is right and (2) what type of join you specify.\nThis becomes somewhat more intuitive when looking at tangible examples so let’s prepare some data to join in different ways!\n\njoin Data Preparation\nFor demonstration purposes, let’s add a new column called record_number to our penguins data and call the new dataframe penguins_tidy. As you can see below, each row is now numbered from 1 to the length of the dataframe.\n\n# Add a column called `record_number` to our penguins dataset\npenguins_tidy &lt;- penguins %&gt;%\n    dplyr::mutate(record_number = 1:n(), .before = dplyr::everything())\n\ndplyr::glimpse(penguins_tidy)\n\nRows: 344\nColumns: 9\n$ record_number     &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nThe palmerpenguins package also has a “penguins_raw” dataset with additional, raw information on the same penguins, such as their sampling region, unique identifier, and the date when their nest was observed. Again, for demonstration purposes, let’s add a new column called record_number and call this new dataframe penguins_extra.\n\n# Add a column called `record_number` to our raw penguins dataset\npenguins_extra &lt;- penguins_raw %&gt;%\n  dplyr::mutate(record_number = 1:n()) %&gt;%\n  # Also keep only desired columns to avoid unnecessary complexity\n  dplyr::select(record_number, Region, `Individual ID`, `Date Egg`)\n\ndplyr::glimpse(penguins_extra)\n\nRows: 344\nColumns: 4\n$ record_number   &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ Region          &lt;chr&gt; \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", \"Anv…\n$ `Individual ID` &lt;chr&gt; \"N1A1\", \"N1A2\", \"N2A1\", \"N2A2\", \"N3A1\", \"N3A2\", \"N4A1\"…\n$ `Date Egg`      &lt;date&gt; 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16, 2007-…\n\n\nNow that we have two dataframes that both have a column called record_number, we can join them together to combine information in various ways!\nAlso, note that if column names include spaces (as in Individual ID and Date Egg) they need to have a “backtick” (`) on either side. On your keyboard, a backtick (`) is on the left just below the “escape” key, and shares a button with the tilde (~).\n\n\nleft_join Example: Prioritize the “Left” Dataframe\n\n\n\n\n\n\nExample\n\n\n\nIn a left_join, we bring the columns from the right dataframe that match rows found in the specified column(s) of the left dataframe.\n\n\n\nWe can specify the column that we want to join based on with by = .... If we don’t provide this argument, then dplyr will automatically join on all matching columns between the left and right dataframes. In our case, we want to left_join by record_number.\nTo better demonstrate that only rows found in the left dataframe will be joined from the right dataframe, we’ll use the pipe %&gt;% to filter the left dataframe before joining.\n\n# Left-join the two dataframes together on the shared column!\npenguins_left_joined &lt;- penguins_tidy %&gt;%\n  dplyr::filter(record_number &lt; 5) %&gt;%\n  dplyr::left_join(y = penguins_extra, by = \"record_number\")\n\ndplyr::glimpse(penguins_left_joined)\n\nRows: 4\nColumns: 12\n$ record_number     &lt;int&gt; 1, 2, 3, 4\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA\n$ sex               &lt;fct&gt; male, female, female, NA\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007\n$ Region            &lt;chr&gt; \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\"\n$ `Individual ID`   &lt;chr&gt; \"N1A1\", \"N1A2\", \"N2A1\", \"N2A2\"\n$ `Date Egg`        &lt;date&gt; 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16\n\n\nWhat we have in the end is penguins_left_joined, a dataframe with information from both penguins_tidy and penguins_extra! All of the rows in our filtered penguins_tidy are kept but only the rows from penguins_extra that have a matching record_number in penguins_tidy are included.\n\n\n\n\nright_join Example: Prioritize the “Right” Dataframe\n\n\n\n\n\n\nExample\n\n\n\nIn a right_join, we bring rows from the left dataframe into the right dataframe based on the values in the specified column(s) of the right dataframe.\n\n\n\nAs the names imply, a right_join is the opposite of a left_join.\n\n\n\n\ninner_join Example: Keep Rows Found in Both Dataframes\n\n\n\n\n\n\nExample\n\n\n\nIn an inner_join, we keep only the rows where the values in the column we are joining by are found in both dataframes.\n\n\n\nThis can be really useful when one of the dataframes includes supplementary data that has incomplete coverage on the other dataframe and you want to simultaneously combine the dataframes and remove the inevitable NAs that will be created.\nFor example, imagine that you have a dataframe of 100 study sites with information on plant growth and a second dataframe of soil chemistry information. Your grant budget was really tight though so you needed to prioritize sample processing and you only have soil chemistry for 20 of the sites where you have plant growth data.\nIf you use inner_join on your plant growth and soil chemistry datasets, you will create a single dataframe with both chemistry and plant data that only has the sites (i.e., rows) where you had data for both. This dataframe then would likely be ready for analysis because you’d have complete data for every site in the new joined dataframe!\nNote that in an inner_join it doesn’t matter which dataframe is “left” and which is “right” because either way you’re only keeping the rows that are found in both dataframes.\n\n\n\n\nfull_join Example: Combine All Data in Both Dataframes\n\n\n\n\n\n\nExample\n\n\n\nIn a full_join, we keep all values and all rows.\n\n\n\nA full_join is “smart” enough to fill with NAs in all rows that don’t match between the two dataframes. Also, just like an inner_join, a full_join doesn’t care about which dataframe is “left” and which is “right” because all columns are getting combined regardless of which is left vs. right.\n\n\n\n\nanti_join Example: Keep Only Columns that Aren’t Shared\n\n\n\n\n\n\nExample\n\n\n\nIn an anti_join, we return rows of the left dataframe that do not have a match in the right dataframe. This can be used to see what will not be included in a join.\n\n\n\nOne case where an anti_join is particularly useful is that of “text mining” where you have one dataframe with a column of individual words that you’ve split apart from a larger block of free text. If you also have a dataframe of one column that contains words that you want to remove from your “actual” data (e.g., “and”, “not”, “I”, “me”, etc.), you can anti_join the two dataframes to quickly remove all of those unwanted words from your text mining dataframe.\n\n\n\n\nAdditional Notes\n\nIf we want to join by more than one matching column, we can specify multiple columns with a vector like so: by = c(\"column1\", \"column2\").\nWe can also use a named vector, by = c(\"column_a\" = \"COLUMN_A\") to match on columns that have different names in each dataframe.",
    "crumbs": [
      "Modules",
      "Join"
    ]
  }
]